## 字符串中最长的连续无重复的子字符串

返回值最长字串的长度

### 暴力法

```c++
/*
	使用 set 容器，记录遍历时的起始索引，遍历使用set容器保存
	当遇到重复的字符后，清空容器，回到 起始索引 + 1 的位置 继续遍历
*/
#include <iostream>
#include <set>
using namespace std;
class  lengthOfLongestSubstring{
    public:
    int My_lengthOfLongestSubstring(string str);
};
int main(){
    lengthOfLongestSubstring fun ;
    string str;
    getline(cin , str);//获取终端用户输入的字符串，不会过滤空格和tab
    int len = fun.My_lengthOfLongestSubstring(str);
    cout << "Maxsize :" <<  len << endl;
}
/*		函数实现		*/
int lengthOfLongestSubstring :: My_lengthOfLongestSubstring(string str){
    set<char> My_set;   //创建集合
    int index = 0 , len = str.length();
    int maxsize = 0;
    while(index < len){
        while(true){
            char now_char = str[index];
            if( My_set.count(now_char) ) //判断当前索引的字符，是否存在set容器中 ， 存在返回 true
            {
                index = index - My_set.size() + 1;      //index 返回开始的位置+1 的索引
                break;
            }
            else{
                My_set.insert(str[index++]);        //不存在，则插入set容器
            }
            if(index == len){               //判断索引是否溢出
                break;
            }
        }
        if(My_set.size() > maxsize){        //判断此时的容器的长度是否为最大值
            maxsize = My_set.size();        
        }
        My_set.clear();     //每次有重复元素，或者索引到最后了，清空容器
    }
    return maxsize;
}
```

### 滑动窗口法

```c++
/*
	使用 set 容器模拟一个 窗口 ， 窗口：左边界 和 右边界
	遍历时：
		1、没遇到重复字符，set 容器插入元素，右边界右移，窗口变长
		2、遇到重复的字符，从 set 容器的begin索引，即窗口的左边界 不断踢出元素，即左边界右移，直到没有重复元素，能够把当前遍历的字符插入set容器为止
		在这个过程中，不断判断容器的长度，保存最大值
*/
#include <iostream>
#include <unordered_set>
using namespace std;
class  lengthOfLongestSubstring{
    public:
    int My_lengthOfLongestSubstring(string str);
};
int main(){
    lengthOfLongestSubstring fun ;
    string str;
    getline(cin , str);//获取终端用户输入的字符串，不会过滤空格和tab
    int len = fun.My_lengthOfLongestSubstring(str);
    cout << "Maxsize :" <<  len << endl;
    return 0;
}
int lengthOfLongestSubstring :: My_lengthOfLongestSubstring(string str){
    int len = str.length();
    unordered_set<char>  My_set;      //定义窗口
    int max_size = 0;
    int i = 0 , j = 0;
    while(i < len && j < len){
        char temp = str[j];
        /*
        unordered_set<char> :: iterator  it  = My_set.find(temp);
        unordered_set<char> :: iterator  it_begin;*/
        if(  it  == My_set.end() ){      //如果不存在，就插入 容器
            My_set.insert(str[j++]);
        }
        else{                           //如果容器中存在该元素，依次不断删除插入的元素，直到能够插入
            /*
            do{
                it_begin = My_set.begin();
                it = My_set.find(temp);
                My_set.erase(it_begin);
            }while(it_begin != it);*/
            My_set.erase(str[i++]);
        }
        if( My_set.size() > max_size){
            max_size = My_set.size();
        }
    }
    return max_size;
}
```

## 字符串子串查找算法 KMP

给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。

**暴力求解**

```c++
#include <iostream>
#include <string>
using namespace std;
int KMP_Src(string  S , string P , int S_index , int P_index){
    while(P_index > 0 && S[S_index] == P[--P_index]){
    }
    while(P_index > 0){
    }
}
int KMP(string  S , string P){
    int S_len = S.length() , P_len = P.length();
    int S_src = 0 , P_left = 0;
    while(S_src < S_len){
        if(S[S_src] == P[P_left]){   //匹配到模式串的第一个字符
            int S_index = S_src + 1;
            int P_index = 1;
            while(P_index < P_len && S[S_index++] == P[P_index++]){
            }
            if(P_index == P_len){
                return S_src;
            }
            else{
                KMP_Src(S , P , --S_index , --P_index)
            }
        }
        S_src++;
    }
    return -1;
}
int main(){
    int index;
    string S , P;
    cin >> S;
    cin >> P;
    if((index = KMP(S , P)) < 0 ){
        cout << "不存在\n";
    }
    else{
        cout << "位置：" << index << endl;
    }
    return 0;
}
```

**KMP 算法**

```c++
#include <iostream>
using namespace std;
class  My_KMP{
    public:
    My_KMP(){
    }
    void Get_next( string str , int * next){
        next[0] = -1;
        int i = 0 , j = -1;
        while( i < str.length()){
            if(j == -1 || str[i] == str[j]){
                i++;
                j++;
                next[i] = j;
            }
            else{
                j = next[j];
            }
        }
    }
    int search(string str , string pattern , int * next){
        int i = 0 , j = 0 , str_len = str.length() , patt_len = pattern.length();
        while( i < str_len && j < patt_len ){
            if( j == -1 || str[i] == pattern[j]){
                i++;
                j++;
            }
            else{
                j = next[j];
            }
        }
        if(j == pattern.length()){
            return i - j;
        }
        else{
            return -1;
        }
    }
};
int main(){
    My_KMP my_Kmp;
    string  pattern , str;
    cin >> str;		//主串
    cin >> pattern; //模式串
    int next[pattern.length()] = {0};		//定义和模式串同样长度的 next 数组
    my_Kmp.Get_next( pattern , next);        //获取 next 数组
    for(int i = 0 ; i < pattern.length() ; i++){
        cout << next[i] << " ";				//打印 next 数组
    }
    cout << "\n";
    cout << my_Kmp.search( str , pattern , next) << endl;	//进行 KMP 算法查找
    return 0;
}
```



## 最长连续公共子序列

要求两个字符串的最长连续公共子序列，一般采用的方法是后缀数组法，即先分别求出两个串的后缀数组，然后比较它们之间的连续公共长度。这个有个处理技巧就是为了确认哪个后缀数组属于哪个串，需要在其中一个串后面贴一个标签，避免混淆。

**动态规划** （空间复杂度 (M + 1)+(N+1)  ， 时间复杂度  M * N）

```c++
/*
       A B C D E F G
     0 0 0 0 0 0 0 0
   B 0 0 1 0 0 0 0 0
   C 0 0 0 2 0 0 0 0
   A 0 1 0 0 0 0 0 0
   E 0 0 0 0 0 1 0 0
   G 0 0 0 0 0 0 0 1
*/
#include <iostream>
using namespace std;
#define max(a,b) (a>b? a:b)
class Longest_conti_com_sub{
    private:
        int max_sub = 0;//用来保存最长的连续公共子序列长度
    public:
        int Get_Longest_conti_com_sub( string str1 , string str2){
            //定义动态规划数组，保存公共子串的长度，和连续公共子串的长度
            //str1 的每个字符都会和 str2 的所有字符进行比较判断 ，并保存判断的结果到 dp数组中
            int dp[str1.length() + 1][str2.length() + 1] = {0};
            for( int i = 1 ; i < str1.length() + 1 ; i++){
                for(int j = 1 ; j < str2.length() + 1 ; j++){
                    if(str1[i - 1] == str2[j - 1]){
                        //每次遇到相同的字符，都会在下标往前移一位的计数上 + 1 ， 由此来累计连续子串的计数
                        dp[i][j] = dp[i-1][j-1] + 1;
                        //获取所有连续子串的最长的值
                        max_sub  = max(max_sub , dp[i][j]); 
                    }
                    else{
                        dp[i][j] = 0;//两个字符不相等，对应的动态数组值置 0
                    }
                }
            }
            return max_sub;
        }
};
int main(){
    Longest_conti_com_sub  lccs;
    string str1 , str2;
    cin >> str1;
    cin >> str2;
    cout << lccs.Get_Longest_conti_com_sub(str1 , str2) << endl;
    return 0;
}
```

## 最长公共子序列

要求两个串的公共子序列，则这些子序列不一定是连续的，对于这类问题通常的解法是采用动态规划

```c++
#include <iostream>

using namespace std;

#define max(a , b)  (a > b ? a : b)
class Longest_com_sub
{
private:
    int max_Longest_com_sub = 0;
public:
    int Get_Longest_com_sub(string str1 , string str2){
        int len1 = str1.length() , len2 = str2.length();
        int dp[len1 + 1][len2 + 1] = {0};
        int i , j;
        for( i = 1 ; i < len1 + 1 ; i++){
            for( j = 1 ; j < len2 + 1 ; j++){
                if( str1[i -1 ] == str2[ j - 1] ){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i - 1][j] , dp[i][j - 1]);
                }
            }
        }
        return dp[i - 1][j - 1];
    }
};
int main(){
    string str1 , str2;
    cin >> str1;
    cin >> str2;
    Longest_com_sub  L_C_B;
    cout << L_C_B.Get_Longest_com_sub(str1 , str2) << endl;
    return 0;
}
```

## 编辑距离算法

编辑距离，又称Levenshtein距离（莱文斯坦距离也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。

```c++
/*
         B D F G E 
       0 1 2 3 4 5
     A 1 1 2 3 4 5
     B 2 1 2 3 4 5
     C 3 2 2 3 4 5
     D 4 3 2 3 4 5
     E 5 4 3 3 4 5
     F 6 5 4 3 4 5
*/
#include <iostream>
#include <math.h>
using namespace std;
#define Min(a , b)  (a < b ? a : b)

class Edit_distance{
    private:
    int Min_edit_distance = INFINITY;   //初始化为无穷大
    public:
    int Get_Min(int a ,int b ,int c){
        return Min( Min(a , b) , c);
    }
    int Get_Min_edit_distance(string src , string dst)
    {
        int src_len = src.length() , dst_len = dst.length();
        int dp[src_len + 1][dst_len + 1];
        for(int i = 0 ; i < src_len + 1; i++){
            dp[i][0] = i;
        }
        for(int j = 0 ; j < dst_len + 1; j++){
            dp[0][j] = j;
        }
        for( int i = 1 ; i < src_len + 1 ; i++){
            for( int j = 1 ; j < dst_len + 1; j++){
                int flag = ( src[i - 1] == dst[j -1] ) ?  0 : 1;
                dp[i][j] = Get_Min( dp[i - 1][j]    + 1,        //删除
                                    dp[i][j-1]      + 1,        //增加  
                                    dp[i - 1][j -1] + flag);    //替换
            }
        }
        return dp[src_len][dst_len];
    }
};

int main(){
    string src , dst;
    cin >> src >> dst;
    Edit_distance  ED;
    cout << ED.Get_Min_edit_distance(src , dst) << endl;
    return 0;
}
```

## 两数之和

```c++
/*
题目描述:
	给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。
	
示例1：
	输入：nums = [2,7,11,15], target = 9
    输出：[0,1]
    解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例2：
	输入：nums = [3,2,4], target = 6
	输出：[1,2]
示例 3：
	输入：nums = [3,3], target = 6
	输出：[0,1]
*/

/*
解题：
	使用允许插入相同键 的无需键值容器 unordered_map
代码：
*/
#include <unordered_map>
#include <iostream>
using namespace std;
class Solution {
public:
    
    vector<int> twoSum(vector<int>& nums, int target) {
        vector<int> result;
        unordered_map<int , int > Map;
        int i;
	   //将vector 数组中的所有元素，插入unordered_map
        for( i = 0; i < nums.size() ; i++){
            Map.insert( {nums[i] , i} );
        }
        //使用unordered_map IO函数 equal_range ：返回一对迭代器，即可相同键的范围
        for( i = 0; i < nums.size() ; i++){
            auto range = Map.equal_range(target - nums[i]);
            //遍历返回的迭代器
            for(auto it = range.first ; it != range.second ; it++){
                if( it->second != i ){	//判断该迭代器所在的键 是否为当前键
                    result.push_back(i);
                    result.push_back(it->second);
                    return result;
                }
            }
        }
        return result;
    }
};

```

## **最长回文字符串**

```c++
/*
给你一个字符串 s，找到 s 中最长的回文子串。
示例1：
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
示例2：
输入：s = "cbbd"
输出："bb"
示例3：
输入：s = "a"
输出："a"
示例4：
输入：s = "ac"
输出："a"
*/
/*
首先我们要确定dp[i][j]的含义，dp[i][j]：表示区间范围[i,j] （注意是左闭右闭）的子串是否是回文子串，如果是dp[i][j]为true，否则为false。
然后我们将整个二位数组都初始化为false；
接着就可以开始确定递归，整体上是两种，就是s[i]与s[j]相等，s[i]与s[j]不相等这两种。
当s[i]与s[j]不相等，那没啥好说的了，dp[i][j]一定是false。
当s[i]与s[j]相等时，这就复杂一些了，有如下三种情况：
情况一：下标i 与 j相同，同一个字符例如a，当然是回文子串
情况二：下标i 与 j相差为1，例如aa，也是文子串
情况三：下标：i 与 j相差大于1的时候，例如cabac，此时s[i]与s[j]已经相同了，我们看i到j区间是不是回文子串就看aba是不是回文就可以了，那么aba的区间就是 i+1 与 j-1区间，这个区间是不是回文就看dp[i + 1][j - 1]是否为true。

前两种情况可以合并为j - i <= 1，而且第三种dp[i + 1][j - 1]与前两种的处理是相同的，都是dp[i][j] = true，所以可以直接放在同一句if(j - i <= 1 || dp[i + 1][j - 1])
记录一下最大长度和开始区间坐标就好了。

作者：lemuria-t
链接：https://leetcode-cn.com/problems/longest-palindromic-substring/solution/cdong-tai-gui-hua-by-lemuria-t-4vgr/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
*/
#include <iostream>
#include <string>
using namespace std;
class Solution {
public:
    string longestPalindrome(string s) {
        int len = s.size();
        int max_size = INT_MIN;
        int begin = 0;
        if( len < 2){
            return s;
        }
        vector<vector<bool>> dp(len , vector<bool>(len , false) );
        for(int i = len - 1 ; i >= 0 ; i--){
            for(int j = i ; j < len ; j++){
                if(s[i] == s[j]){
                    if(j - i <= 1 || dp[i+1][j-1]){
                        if(j - i + 1 > max_size){
                            max_size = j - i + 1 ;
                            begin = i;
                        }
                        dp[i][j] = true;
                    }
                }
            }
        }
        return s.substr(begin , max_size);
    }
};
```

## 寻找两个正序数组的中位数

```c++
/*
	给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。
	算法的时间复杂度应该为 O(log (m+n)) 。
	示例1：
             输入：nums1 = [1,3], nums2 = [2]
     		输出：2.00000
             解释：合并数组 = [1,2,3] ，中位数 2
    示例2：
    	输入：nums1 = [1,2], nums2 = [3,4]
        输出：2.50000
        解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
	示例3：
	    输入：nums1 = [0,0], nums2 = [0,0]
	    输出：0.00000
*/
/*
	假设两个有序数组分别是 \text{A}A 和 \text{B}B。要找到第 kk 个元素，我们可以比较 \text{A}[k/2-1]A[k/2−1] 和 \text{B}[k/2-1]B[k/2−1]，其中 // 表示整数除法。由于 \text{A}[k/2-1]A[k/2−1] 和 \text{B}[k/2-1]B[k/2−1] 的前面分别有 \text{A}[0\,..\,k/2-2]A[0..k/2−2] 和 \text{B}[0\,..\,k/2-2]B[0..k/2−2]，即 k/2-1k/2−1 个元素，对于 \text{A}[k/2-1]A[k/2−1] 和 \text{B}[k/2-1]B[k/2−1] 中的较小值，最多只会有 (k/2-1)+(k/2-1) \leq k-2(k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 kk 小的数了。

因此我们可以归纳出三种情况：

		1、如果 \text{A}[k/2-1] < \text{B}[k/2-1]A[k/2−1]<B[k/2−1]，则比 \text{A}[k/2-1]A[k/2−1] 小的数最多只有 \text{A}A 的前 k/2-1k/2−1 个数和 \text{B}B 的前 k/2-1k/2−1 个数，即比 \text{A}[k/2-1]A[k/2−1] 小的数最多只有 k-2k−2 个，因此 \text{A}[k/2-1]A[k/2−1] 不可能是第 kk 个数，\text{A}[0]A[0] 到 \text{A}[k/2-1]A[k/2−1] 也都不可能是第 kk 个数，可以全部排除。

		2、如果 \text{A}[k/2-1] > \text{B}[k/2-1]A[k/2−1]>B[k/2−1]，则可以排除 \text{B}[0]B[0] 到 \text{B}[k/2-1]B[k/2−1]。

		3、如果 \text{A}[k/2-1] = \text{B}[k/2-1]A[k/2−1]=B[k/2−1]，则可以归入第一种情况处理。

有以下三种情况需要特殊处理：

		1、如果 \text{A}[k/2-1]A[k/2−1] 或者 \text{B}[k/2-1]B[k/2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 kk 的值，而不能直接将 kk 减去 k/2k/2。

		2、如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 kk 小的元素。

		3、如果 k=1k=1，我们只要返回两个数组首元素的最小值即可。
*/
#define Min(a , b)  (a<b? a:b)
class Binary_search{
    public:
        double Get_TOP_Minthk(vector<int>& nums1 , vector<int>& nums2 , int k){
            //获取两个正序数组的长度
            int len1 = nums1.size() , len2 = nums2.size();
            //索引
            int index1 = 0 , index2 = 0;
            while(true){
                //循环退出条件
                if(index1 == len1){
                    //1、数组1 越界
                    //返回数组2 index2索引开始的 第k个元素
                    return nums2[index2 + k - 1];
                }
                else if(index2 == len2){
                    //2、数组2 越界
                    //返回数组1 index1索引开始的 第K个元素
                    return nums1[index1 + k - 1];
                }
                else if(k == 1){
                    //当 K 为1 时
                    //返回两个数组 索引元素 中更小的那个
                    return Min(nums1[index1] , nums2[index2]);
                }

                //正常执行循环时
                //比较 index* + K/2 - 1
                //这里可以防止数组访问 index* + k/2 - 1 时越界
                int newindex1 = Min( index1 + k/2 - 1 , len1 - 1);
                int newindex2 = Min( index2 + k/2 - 1 , len2 - 1);
                if(nums1[newindex1] <= nums2[newindex2]){
                    //除去 nums1 的左边 K/2 个元素
                    k -= (newindex1 - index1 + 1);
                    //更新 nums1 的索引
                    index1 = newindex1 + 1;
                }
                else{
                    //除去 nums2 的左边 K/2 个元素
                    k -= (newindex2 - index2 + 1);
                    //更新 nums2 的索引
                    index2 = newindex2 + 1;
                }
            }
        }
};
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int total_lens = nums1.size() + nums2.size();
        Binary_search  Bin_s;
        if(total_lens % 2 == 1){
            return Bin_s.Get_TOP_Minthk(nums1 , nums2 , total_lens / 2 + 1);
        }
        else{
            //当两个数组长度之和 时偶数， 则获取 total_lens / 2 和 total_lens / 2 + 1 进行相加在对2整除
            return (Bin_s.Get_TOP_Minthk(nums1 , nums2 , total_lens / 2) + 
                        Bin_s.Get_TOP_Minthk(nums1 , nums2 , total_lens / 2 + 1)) / 2;
        }
    }
};
```

