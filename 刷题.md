## 字符串中最长的连续无重复的子字符串

返回值最长字串的长度

### 暴力法

```c++
/*
	使用 set 容器，记录遍历时的起始索引，遍历使用set容器保存
	当遇到重复的字符后，清空容器，回到 起始索引 + 1 的位置 继续遍历
*/
#include <iostream>
#include <set>
using namespace std;
class  lengthOfLongestSubstring{
    public:
    int My_lengthOfLongestSubstring(string str);
};
int main(){
    lengthOfLongestSubstring fun ;
    string str;
    getline(cin , str);//获取终端用户输入的字符串，不会过滤空格和tab
    int len = fun.My_lengthOfLongestSubstring(str);
    cout << "Maxsize :" <<  len << endl;
}
/*		函数实现		*/
int lengthOfLongestSubstring :: My_lengthOfLongestSubstring(string str){
    set<char> My_set;   //创建集合
    int index = 0 , len = str.length();
    int maxsize = 0;
    while(index < len){
        while(true){
            char now_char = str[index];
            if( My_set.count(now_char) ) //判断当前索引的字符，是否存在set容器中 ， 存在返回 true
            {
                index = index - My_set.size() + 1;      //index 返回开始的位置+1 的索引
                break;
            }
            else{
                My_set.insert(str[index++]);        //不存在，则插入set容器
            }
            if(index == len){               //判断索引是否溢出
                break;
            }
        }
        if(My_set.size() > maxsize){        //判断此时的容器的长度是否为最大值
            maxsize = My_set.size();        
        }
        My_set.clear();     //每次有重复元素，或者索引到最后了，清空容器
    }
    return maxsize;
}
```

### 滑动窗口法

```c++
/*
	使用 set 容器模拟一个 窗口 ， 窗口：左边界 和 右边界
	遍历时：
		1、没遇到重复字符，set 容器插入元素，右边界右移，窗口变长
		2、遇到重复的字符，从 set 容器的begin索引，即窗口的左边界 不断踢出元素，即左边界右移，直到没有重复元素，能够把当前遍历的字符插入set容器为止
		在这个过程中，不断判断容器的长度，保存最大值
*/
#include <iostream>
#include <unordered_set>
using namespace std;
class  lengthOfLongestSubstring{
    public:
    int My_lengthOfLongestSubstring(string str);
};
int main(){
    lengthOfLongestSubstring fun ;
    string str;
    getline(cin , str);//获取终端用户输入的字符串，不会过滤空格和tab
    int len = fun.My_lengthOfLongestSubstring(str);
    cout << "Maxsize :" <<  len << endl;
    return 0;
}
int lengthOfLongestSubstring :: My_lengthOfLongestSubstring(string str){
    int len = str.length();
    unordered_set<char>  My_set;      //定义窗口
    int max_size = 0;
    int i = 0 , j = 0;
    while(i < len && j < len){
        char temp = str[j];
        /*
        unordered_set<char> :: iterator  it  = My_set.find(temp);
        unordered_set<char> :: iterator  it_begin;*/
        if(  it  == My_set.end() ){      //如果不存在，就插入 容器
            My_set.insert(str[j++]);
        }
        else{                           //如果容器中存在该元素，依次不断删除插入的元素，直到能够插入
            /*
            do{
                it_begin = My_set.begin();
                it = My_set.find(temp);
                My_set.erase(it_begin);
            }while(it_begin != it);*/
            My_set.erase(str[i++]);
        }
        if( My_set.size() > max_size){
            max_size = My_set.size();
        }
    }
    return max_size;
}
```

## 字符串子串查找算法 KMP

给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。

```c++

```



## 最长连续公共子序列

要求两个字符串的最长连续公共子序列，一般采用的方法是后缀数组法，即先分别求出两个串的后缀数组，然后比较它们之间的连续公共长度。这个有个处理技巧就是为了确认哪个后缀数组属于哪个串，需要在其中一个串后面贴一个标签，避免混淆。

**动态规划** （空间复杂度 (M + 1)+(N+1)  ， 时间复杂度  M * N）

```c++
/*
       A B C D E F G
     0 0 0 0 0 0 0 0
   B 0 0 1 0 0 0 0 0
   C 0 0 0 2 0 0 0 0
   A 0 1 0 0 0 0 0 0
   E 0 0 0 0 0 1 0 0
   G 0 0 0 0 0 0 0 1
*/
#include <iostream>
using namespace std;
#define max(a,b) (a>b? a:b)
class Longest_conti_com_sub{
    private:
        int max_sub = 0;//用来保存最长的连续公共子序列长度
    public:
        int Get_Longest_conti_com_sub( string str1 , string str2){
            //定义动态规划数组，保存公共子串的长度，和连续公共子串的长度
            //str1 的每个字符都会和 str2 的所有字符进行比较判断 ，并保存判断的结果到 dp数组中
            int dp[str1.length() + 1][str2.length() + 1] = {0};
            for( int i = 1 ; i < str1.length() + 1 ; i++){
                for(int j = 1 ; j < str2.length() + 1 ; j++){
                    if(str1[i - 1] == str2[j - 1]){
                        //每次遇到相同的字符，都会在下标往前移一位的计数上 + 1 ， 由此来累计连续子串的计数
                        dp[i][j] = dp[i-1][j-1] + 1;
                        //获取所有连续子串的最长的值
                        max_sub  = max(max_sub , dp[i][j]); 
                    }
                    else{
                        dp[i][j] = 0;//两个字符不相等，对应的动态数组值置 0
                    }
                }
            }
            return max_sub;
        }
};
int main(){
    Longest_conti_com_sub  lccs;
    string str1 , str2;
    cin >> str1;
    cin >> str2;
    cout << lccs.Get_Longest_conti_com_sub(str1 , str2) << endl;
    return 0;
}
```



## 最长公共子序列

要求两个串的公共子序列，则这些子序列不一定是连续的，对于这类问题通常的解法是采用动态规划

## 字符串模糊匹配（状态机）

## 编辑距离算法

编辑距离，又称Levenshtein距离（莱文斯坦距离也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。

