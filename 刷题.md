## 字符串中最长的连续无重复的子字符串

返回值最长字串的长度

### 暴力法

```c++
/*
	使用 set 容器，记录遍历时的起始索引，遍历使用set容器保存
	当遇到重复的字符后，清空容器，回到 起始索引 + 1 的位置 继续遍历
*/
#include <iostream>
#include <set>
using namespace std;
class  lengthOfLongestSubstring{
    public:
    int My_lengthOfLongestSubstring(string str);
};
int main(){
    lengthOfLongestSubstring fun ;
    string str;
    getline(cin , str);//获取终端用户输入的字符串，不会过滤空格和tab
    int len = fun.My_lengthOfLongestSubstring(str);
    cout << "Maxsize :" <<  len << endl;
}
/*		函数实现		*/
int lengthOfLongestSubstring :: My_lengthOfLongestSubstring(string str){
    set<char> My_set;   //创建集合
    int index = 0 , len = str.length();
    int maxsize = 0;
    while(index < len){
        while(true){
            char now_char = str[index];
            if( My_set.count(now_char) ) //判断当前索引的字符，是否存在set容器中 ， 存在返回 true
            {
                index = index - My_set.size() + 1;      //index 返回开始的位置+1 的索引
                break;
            }
            else{
                My_set.insert(str[index++]);        //不存在，则插入set容器
            }
            if(index == len){               //判断索引是否溢出
                break;
            }
        }
        if(My_set.size() > maxsize){        //判断此时的容器的长度是否为最大值
            maxsize = My_set.size();        
        }
        My_set.clear();     //每次有重复元素，或者索引到最后了，清空容器
    }
    return maxsize;
}
```

### 滑动窗口法

```c++
/*
	使用 set 容器模拟一个 窗口 ， 窗口：左边界 和 右边界
	遍历时：
		1、没遇到重复字符，set 容器插入元素，右边界右移，窗口变长
		2、遇到重复的字符，从 set 容器的begin索引，即窗口的左边界 不断踢出元素，即左边界右移，直到没有重复元素，能够把当前遍历的字符插入set容器为止
		在这个过程中，不断判断容器的长度，保存最大值
*/
#include <iostream>
#include <unordered_set>
using namespace std;
class  lengthOfLongestSubstring{
    public:
    int My_lengthOfLongestSubstring(string str);
};
int main(){
    lengthOfLongestSubstring fun ;
    string str;
    getline(cin , str);//获取终端用户输入的字符串，不会过滤空格和tab
    int len = fun.My_lengthOfLongestSubstring(str);
    cout << "Maxsize :" <<  len << endl;
    return 0;
}
int lengthOfLongestSubstring :: My_lengthOfLongestSubstring(string str){
    int len = str.length();
    unordered_set<char>  My_set;      //定义窗口
    int max_size = 0;
    int i = 0 , j = 0;
    while(i < len && j < len){
        char temp = str[j];
        /*
        unordered_set<char> :: iterator  it  = My_set.find(temp);
        unordered_set<char> :: iterator  it_begin;*/
        if(  it  == My_set.end() ){      //如果不存在，就插入 容器
            My_set.insert(str[j++]);
        }
        else{                           //如果容器中存在该元素，依次不断删除插入的元素，直到能够插入
            /*
            do{
                it_begin = My_set.begin();
                it = My_set.find(temp);
                My_set.erase(it_begin);
            }while(it_begin != it);*/
            My_set.erase(str[i++]);
        }
        if( My_set.size() > max_size){
            max_size = My_set.size();
        }
    }
    return max_size;
}
```

## 字符串子串查找算法 KMP

给定一个主串（以 S 代替）和模式串（以 P 代替），要求找出 P 在 S 中出现的位置，此即串的模式匹配问题。

**暴力求解**

```c++
#include <iostream>
#include <string>
using namespace std;
int KMP_Src(string  S , string P , int S_index , int P_index){
    while(P_index > 0 && S[S_index] == P[--P_index]){
    }
    while(P_index > 0){
    }
}
int KMP(string  S , string P){
    int S_len = S.length() , P_len = P.length();
    int S_src = 0 , P_left = 0;
    while(S_src < S_len){
        if(S[S_src] == P[P_left]){   //匹配到模式串的第一个字符
            int S_index = S_src + 1;
            int P_index = 1;
            while(P_index < P_len && S[S_index++] == P[P_index++]){
            }
            if(P_index == P_len){
                return S_src;
            }
            else{
                KMP_Src(S , P , --S_index , --P_index)
            }
        }
        S_src++;
    }
    return -1;
}
int main(){
    int index;
    string S , P;
    cin >> S;
    cin >> P;
    if((index = KMP(S , P)) < 0 ){
        cout << "不存在\n";
    }
    else{
        cout << "位置：" << index << endl;
    }
    return 0;
}
```

**KMP 算法**

```c++
#include <iostream>
using namespace std;
class  My_KMP{
    public:
    My_KMP(){
    }
    void Get_next( string str , int * next){
        next[0] = -1;
        int i = 0 , j = -1;
        while( i < str.length()){
            if(j == -1 || str[i] == str[j]){
                i++;
                j++;
                next[i] = j;
            }
            else{
                j = next[j];
            }
        }
    }
    int search(string str , string pattern , int * next){
        int i = 0 , j = 0 , str_len = str.length() , patt_len = pattern.length();
        while( i < str_len && j < patt_len ){
            if( j == -1 || str[i] == pattern[j]){
                i++;
                j++;
            }
            else{
                j = next[j];
            }
        }
        if(j == pattern.length()){
            return i - j;
        }
        else{
            return -1;
        }
    }
};
int main(){
    My_KMP my_Kmp;
    string  pattern , str;
    cin >> str;		//主串
    cin >> pattern; //模式串
    int next[pattern.length()] = {0};		//定义和模式串同样长度的 next 数组
    my_Kmp.Get_next( pattern , next);        //获取 next 数组
    for(int i = 0 ; i < pattern.length() ; i++){
        cout << next[i] << " ";				//打印 next 数组
    }
    cout << "\n";
    cout << my_Kmp.search( str , pattern , next) << endl;	//进行 KMP 算法查找
    return 0;
}
```



## 最长连续公共子序列

要求两个字符串的最长连续公共子序列，一般采用的方法是后缀数组法，即先分别求出两个串的后缀数组，然后比较它们之间的连续公共长度。这个有个处理技巧就是为了确认哪个后缀数组属于哪个串，需要在其中一个串后面贴一个标签，避免混淆。

**动态规划** （空间复杂度 (M + 1)+(N+1)  ， 时间复杂度  M * N）

```c++
/*
       A B C D E F G
     0 0 0 0 0 0 0 0
   B 0 0 1 0 0 0 0 0
   C 0 0 0 2 0 0 0 0
   A 0 1 0 0 0 0 0 0
   E 0 0 0 0 0 1 0 0
   G 0 0 0 0 0 0 0 1
*/
#include <iostream>
using namespace std;
#define max(a,b) (a>b? a:b)
class Longest_conti_com_sub{
    private:
        int max_sub = 0;//用来保存最长的连续公共子序列长度
    public:
        int Get_Longest_conti_com_sub( string str1 , string str2){
            //定义动态规划数组，保存公共子串的长度，和连续公共子串的长度
            //str1 的每个字符都会和 str2 的所有字符进行比较判断 ，并保存判断的结果到 dp数组中
            int dp[str1.length() + 1][str2.length() + 1] = {0};
            for( int i = 1 ; i < str1.length() + 1 ; i++){
                for(int j = 1 ; j < str2.length() + 1 ; j++){
                    if(str1[i - 1] == str2[j - 1]){
                        //每次遇到相同的字符，都会在下标往前移一位的计数上 + 1 ， 由此来累计连续子串的计数
                        dp[i][j] = dp[i-1][j-1] + 1;
                        //获取所有连续子串的最长的值
                        max_sub  = max(max_sub , dp[i][j]); 
                    }
                    else{
                        dp[i][j] = 0;//两个字符不相等，对应的动态数组值置 0
                    }
                }
            }
            return max_sub;
        }
};
int main(){
    Longest_conti_com_sub  lccs;
    string str1 , str2;
    cin >> str1;
    cin >> str2;
    cout << lccs.Get_Longest_conti_com_sub(str1 , str2) << endl;
    return 0;
}
```

## 最长公共子序列

要求两个串的公共子序列，则这些子序列不一定是连续的，对于这类问题通常的解法是采用动态规划

```c++
#include <iostream>

using namespace std;

#define max(a , b)  (a > b ? a : b)
class Longest_com_sub
{
private:
    int max_Longest_com_sub = 0;
public:
    int Get_Longest_com_sub(string str1 , string str2){
        int len1 = str1.length() , len2 = str2.length();
        int dp[len1 + 1][len2 + 1] = {0};
        int i , j;
        for( i = 1 ; i < len1 + 1 ; i++){
            for( j = 1 ; j < len2 + 1 ; j++){
                if( str1[i -1 ] == str2[ j - 1] ){
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                }
                else{
                    dp[i][j] = max(dp[i - 1][j] , dp[i][j - 1]);
                }
            }
        }
        return dp[i - 1][j - 1];
    }
};
int main(){
    string str1 , str2;
    cin >> str1;
    cin >> str2;
    Longest_com_sub  L_C_B;
    cout << L_C_B.Get_Longest_com_sub(str1 , str2) << endl;
    return 0;
}
```

## 编辑距离算法

编辑距离，又称Levenshtein距离（莱文斯坦距离也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。

```c++
/*
         B D F G E 
       0 1 2 3 4 5
     A 1 1 2 3 4 5
     B 2 1 2 3 4 5
     C 3 2 2 3 4 5
     D 4 3 2 3 4 5
     E 5 4 3 3 4 5
     F 6 5 4 3 4 5
*/
#include <iostream>
#include <math.h>
using namespace std;
#define Min(a , b)  (a < b ? a : b)

class Edit_distance{
    private:
    int Min_edit_distance = INFINITY;   //初始化为无穷大
    public:
    int Get_Min(int a ,int b ,int c){
        return Min( Min(a , b) , c);
    }
    int Get_Min_edit_distance(string src , string dst)
    {
        int src_len = src.length() , dst_len = dst.length();
        int dp[src_len + 1][dst_len + 1];
        for(int i = 0 ; i < src_len + 1; i++){
            dp[i][0] = i;
        }
        for(int j = 0 ; j < dst_len + 1; j++){
            dp[0][j] = j;
        }
        for( int i = 1 ; i < src_len + 1 ; i++){
            for( int j = 1 ; j < dst_len + 1; j++){
                int flag = ( src[i - 1] == dst[j -1] ) ?  0 : 1;
                dp[i][j] = Get_Min( dp[i - 1][j]    + 1,        //删除
                                    dp[i][j-1]      + 1,        //增加  
                                    dp[i - 1][j -1] + flag);    //替换
            }
        }
        return dp[src_len][dst_len];
    }
};

int main(){
    string src , dst;
    cin >> src >> dst;
    Edit_distance  ED;
    cout << ED.Get_Min_edit_distance(src , dst) << endl;
    return 0;
}
```

