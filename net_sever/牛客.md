## 第一章 Linux系统编程入门

### 1.1 GCC

#### 1.1.1 gcc编译流程

C文件 -> 预处理文件  ->  汇编文件  ->  链接 ->  可执行文件

命令：

gcc main.c -E -o main.i  |  gcc main.c -E

生成：预处理后的源代码  main.i

gcc main.i -S -o main.s  |  gcc main.c -S

生成：汇编代码  main.s

gcc  main.c  -o   main.o   -D DEBUG

作用：给程序指定一个宏

gcc main.c -o main.o  -Wall

作用：显示出所有的警告信息。

#### 1.1.2  gcc 和 g++的区别

1、gcc 和 g++ 都可以互相编译 .c或者.cpp文件 ， 但是gcc 不能自动和C++程序使用的库进行联接，所以习惯直接用g++编译.cpp文件。

2、__cplusplus 宏，只是标志着编译器将会把代码按 C 还是  C++ 语法来解释，也就是说，使用 gcc 去编译 .cpp文件，该宏是会被定义的。

3、编译可以用 gcc / g++ , 而链接可以用  g++   或者   gcc   -lstdc++ 。在编译阶段，g++ 自动调用了 gcc 。

### 1.2 静态库

#### 1.2.1 静态库的命名

Linux：libxxx.a  

#### 1.2.2 静态库的制作

1、gcc  获得  .o  文件

gcc -c  ***.c

2、将 .o  文件打包，使用  ar (archive)

ar   rcs   libxxx.a    xxx.o   xxx.o

r  : 将文件插入备存文件中

c  :  建立备存文件

s  :  索引

#### 1.2.2 静态库的使用

gcc    main.c   -o    app   -I   ./include/    -L   ./lib/    -l     静态库名

-I  : 指定头文件的位置

-L ：指定静态库的位置

-l  :  指定静态库的名称      **注意是静态库的名称，而不是静态库的文件名    比如 libcalc.a  静态库的名称为：calc**

### 1.3 动态库

#### 1.3.1 动态库的命名

Linux：libxxx.so

#### 1.3.2 动态库的制作

1、gcc 得到  .o  文件 ， 得到与位置无关的代码。

gcc  -c   -fpic/-fPIC   a.c   b.c

2、gcc  得到动态库

gcc  -shared   a.o  b.o  -o  libcalc.so

#### 1.3.3 动态库的使用原理

查看可执行文件依赖的动态库链接情况：

ldd   可执行文件

​		ldd app 
​        linux-vdso.so.1 (0x00007fff185ed000)   //  括号内的事动态库的内存地址
​        libcalc.so => not found
​        libc.so.6 => /lib64/libc.so.6 (0x00007f1c97da0000)
​        /lib64/ld-linux-x86-64.so.2 (0x00007f1c98165000)

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。

**系统是如何将动态库载入内存的？**

对于 elf 格式的可执行程序，是由 ld-linux.so 来完成的，它先后搜索 elf 文件的  DT_RPATH 段  ->  环境变量  LD_LIBRARY_PATH   ->  /etc/ld.so.cache 文件列表  ->  /lib/ , /usr/lib  目录找到库文件后将其载入内存。

#### 1.3.3 解决动态库链接失败的方法

**方法1** ：配置 LD_LIBRARY_PATH  （临时的)

export    LD_LIBRARY_PATH  =  $LD_LIBRARY_PATH:  /home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

查看是否配置成功： echo  LD_LIBRARY_PATH

:/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

**缺点**：这个环境变量只是临时的存在与终端，一旦终端关闭，就失效了。

**方法2** ：用户级别的永久配置

在家目录下 ： cd  ~/

打开 .bashrc 文件  :     vim   .bashrc

在最后一行添加：

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

更新 配置： .   .bashrc

**方法3** ：系统级别的永久配置

同样的方法，只不过是在  /ext/profile 文件的最后一行进行添加。

**方法4** ：配置  /etc/ld.so.cache  文件列表

将绝对路径：

/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib  

添加到文件 /etc/ld.so.conf 的最后一行

更新： sudo  ldconfig

**方法4 ：** 将动态库文件添加到 /lib/ , /usr/lib  目录

**这种方法不推荐 ， 这很容易使得自己定义的库文件和系统的库文件产生冲突(重名 覆盖)**，

推荐：**方法2 3 4**

