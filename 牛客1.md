## 第一章 Linux系统编程入门

### 1.1 GCC

#### 1.1.1 gcc编译流程

C文件 -> 预处理文件  ->  汇编文件  ->  链接 ->  可执行文件

命令：

```shell
gcc main.c -E -o main.i  |  gcc main.c -E
```

生成：预处理后的源代码  main.i

```shell
gcc main.i -S -o main.s  |  gcc main.c -生成：汇编代码  main.s
```



```shell
gcc  main.c  -o   main.o   -D DEBUG
```

作用：给程序指定一个宏

```shell
gcc main.c -o main.o  -Wall
```

作用：显示出所有的警告信息。

#### 1.1.2  gcc 和 g++的区别

1、gcc 和 g++ 都可以互相编译 .c或者.cpp文件 ， 但是gcc 不能自动和C++程序使用的库进行联接，所以习惯直接用g++编译.cpp文件。

2、__cplusplus 宏，只是标志着编译器将会把代码按 C 还是  C++ 语法来解释，也就是说，使用 gcc 去编译 .cpp文件，该宏是会被定义的。

3、编译可以用 gcc / g++ , 而链接可以用  g++   或者   gcc   -lstdc++ 。在编译阶段，g++ 自动调用了 gcc 。

### 1.2 静态库

#### 1.2.1 静态库的命名

Linux：libxxx.a  

#### 1.2.2 静态库的制作

1、gcc  获得  .o  文件

```shell
gcc -c  ***.c
```

2、将 .o  文件打包，使用  ar (archive)

```shell
ar   rcs   libxxx.a    xxx.o   xxx.o
```

r  : 将文件插入备存文件中

c  :  建立备存文件

s  :  索引

#### 1.2.2 静态库的使用

```shell
gcc    main.c   -o    app   -I   ./include/    -L   ./lib/    -l     静态库名
```

-I  : 指定头文件的位置

-L ：指定静态库的位置

-l  :  指定静态库的名称      **注意是静态库的名称，而不是静态库的文件名    比如 libcalc.a  静态库的名称为：calc**

### 1.3 动态库

#### 1.3.1 动态库的命名

Linux：libxxx.so

#### 1.3.2 动态库的制作

1、gcc 得到  .o  文件 ， 得到与位置无关的代码。

```shell
gcc  -c   -fpic/-fPIC   a.c   b.c
```

2、gcc  得到动态库

```shell
gcc  -shared   a.o  b.o  -o  libcalc.so
```

#### 1.3.3 动态库的使用原理

查看可执行文件依赖的动态库链接情况：

ldd   可执行文件

​		ldd app 
​        linux-vdso.so.1 (0x00007fff185ed000)   //  括号内的事动态库的内存地址
​        libcalc.so => not found
​        libc.so.6 => /lib64/libc.so.6 (0x00007f1c97da0000)
​        /lib64/ld-linux-x86-64.so.2 (0x00007f1c98165000)

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。

**系统是如何将动态库载入内存的？**

对于 elf 格式的可执行程序，是由 ld-linux.so 来完成的，它先后搜索 elf 文件的  DT_RPATH 段  ->  环境变量  LD_LIBRARY_PATH   ->  /etc/ld.so.cache 文件列表  ->  /lib/ , /usr/lib  目录找到库文件后将其载入内存。

#### 1.3.4 解决动态库链接失败的方法

**方法1** ：配置 LD_LIBRARY_PATH  （临时的)

export    LD_LIBRARY_PATH  =  $LD_LIBRARY_PATH:  /home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

查看是否配置成功： echo  LD_LIBRARY_PATH

:/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

**缺点**：这个环境变量只是临时的存在与终端，一旦终端关闭，就失效了。

**方法2** ：用户级别的永久配置

在家目录下 ： cd  ~/

打开 .bashrc 文件  :     vim   .bashrc

在最后一行添加：

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

更新 配置： .   .bashrc

**方法3** ：系统级别的永久配置

同样的方法，只不过是在  /ext/profile 文件的最后一行进行添加。

**方法4** ：配置  /etc/ld.so.cache  文件列表

将绝对路径：

/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib  

添加到文件 /etc/ld.so.conf 的最后一行

更新： sudo  ldconfig

**方法4 ：** 将动态库文件添加到 /lib/ , /usr/lib  目录

**这种方法不推荐 ， 这很容易使得自己定义的库文件和系统的库文件产生冲突(重名 覆盖)**，

推荐：**方法2 3 4**

#### 1.3.5 静态库和动态库的优缺点

##### 静态库的优缺点：

###### 优点：

1、静态库被打包到应用程序中加载速度快

2、发布程序无需提供静态库，移植方便

###### 缺点：

1、消耗系统资源，浪费内存

2、更新、部署、发布麻烦

##### 动态库的优缺点：

###### 优点：

1、可以实现进程间资源共享 (共享库)

2、更新、部署、发布简单

3、可以控制何时加载动态库

###### 缺点：

1、相对来说，加载速度比静态库慢

2、发布程序时，需要提供依赖的动态库

### 1.4  Makefile

#### 1.4.1 makefile的作用

1、makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，实现“自动化编译” 。

#### 1.4.2 makefile 规则

1、一个makefile 文件中可以有一个或者多个规则

​			目标  ....  ：依赖  .....

​					命令(shell  命令)

​					.....

目标：最终要生成的文件(伪目标除外)

依赖：生成目标文件所需要的文件或是目标

命令：通过执行命令对依赖操作生成目标(命令前必须 tab 缩进)

2、makefile中的其他规则一般都是为第一条规则服务的。

```makefile
app : main.c  printf.c
	gcc main.c printf.c -o app
```

#### 1.4.3 makefile的工作原理

1、命令在执行之前，需要先检查规则中的依赖是否存在

​		1.1 如果存在，执行命令

​		1.2 如果不存在，向下检查其他的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令。

```makefile
app : main.o  printf.o
	gcc main.o printf.o -o app
main.o : main.c
	gcc -c main.c -o main.o
printf.o : printf.c
	gcc -c printf.c -o printf.o
```

2、检查更新

2.1 如果依赖的最新更新时间比目标的时间晚，需要重新生成目标

2.2 如果依赖的最新更新时间比目标的时间早，目标不需要更新，对应规则中的命令不要被执行

```shell
[dzl@localhost lession4_makefile]$ make
make: “app”已是最新。
```

当我们只修改main.c时。

```shell
[dzl@localhost lession4_makefile]$ make
gcc -c main.c -o main.o
gcc main.o printf.o -o app
```

所以上面写的第二个版本的makefile比第一个版本的更好。

#### 1.4.4 变量

1、自定义变量

变量名=变量值		var=hello

2、预定义变量

AR：归档维护程序的名称，默认值为ar

CC：C 编译器的名称，默认值为 cc

CXX：C++ 编译器的名称，默认值为 g++

$@：目标的完整名称

$<：第一个依赖文件的名称

$^：所有的依赖文件

3、获取变量的值

$(变量名)

```makefile
src=main.o  printf.o
target=app
$(target) : $(src)
	$(CC) $^ -o $@
```

#### 1.4.5 模式匹配

```makefile
printf.o : printf.c
	gcc -c printf.c -o printf.o
```

%.o ：%.c

%：通配符，匹配一个字符串

两个%匹配的是同一个字符串

```makefile
%.o : %.c
	gcc -c $< -o $@
```

#### 1.4.6 函数

1、$(wildcard   PATTERN .... )

功能：获取指定目录下指定类型的文件列表

参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔

返回：得到的若干个文件的文件列表，文件名之间使用空格间隔

示例：

```makefile
$( wildcard  *.c  ./sub/*.c )
```

该函数，获取当前路径和当前路径下的sub路径下的 所以 .c 文件

返回值格式：a.c  b.c  c.c

2、$(patsubst  <pattern>,<replacement>,<text>)

功能：查找<text>中的单词(单词以‘空格’、"Tab"或"回车""换行" 分隔)是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。

<pattern>可以包括通配符'%' , 表示任意长度的字串。如果<replacement>中也包含'%'，那么，<replacement>中的这个'%'将是<pattern>中的那个%所代表的字串。

返回：函数返回被替换过后的字符串

示例：

```makefile
$(patsubst  %.c , %.o , x.c bar.c)
```

返回值格式：x.o   bar.o

```makefile
src=$(wildcard  ./*.c)
objs=$(patsubst %.c , %.o , $(src))
target=app
$(target) : $(objs)
	$(CC) $(objs) -o $(target)
```

#### 1.4.7 clean 伪目标

由于clean并不依赖任何文件，所以为了使得make  clean那个执行

需要设置伪目标

```makefile
.PHONY:clean		#将clean设置为伪目标
clean:
	rm  $(objs)  -f
```

### 1.5  GDB 调试

#### 1.5.1 GDB 功能

1、启动程序

2、设置断点(断点可以是条件表达式)

3、咋程序停止时，可以检查程序中的某些事情，如果变量值

4、可以改变程序，将一个 bug 产生的影响修正，从而测试其他bug

#### 1.5.2 GDB 准备工作

1、在为调试而编译时，关掉编译器的优化选项('-o')，打开调试选项('-g')。另外，'-Wall' 打开所有warning。

示例：

```shell
gcc  -g   -Wall program.c  -o  program 
```

'-g' 选项的作用：在可执行文件中加入源代码的信息，所以在调试时，必须保证 gdb 能找到源文件。

#### 1.5.3 GDB命令 -- 启动、退出、 查看代码

开始：gdb   可执行文件

退出：quit / q

使用帮助：help

查看当前代码：

list / l     (从默认位置显示)

list / l     行号     (从指定的行显示)

list / l     函数名    (从指定的函数显示)

查看当前文件代码：

list  / l     文件名 ：行号

list  / l     文件名 ：函数名

显示 / 设置显示的行数：

show   list / listsize  

set   list / listsize   行数

#### 1.5.4 断点操作

**设置断点**

b/break   行号

b/break   函数名

b/break   文件名：行号

b/break	文件名：函数

**查看断点**

i/info	b/break

**删除断点**

d/del/delete	断点编号

**设置断点无效**

dis/disable	断点编号

```makefile
(gdb) disable 2
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400601 in main at main.c:6
2       breakpoint     keep n   0x0000000000400664 in bubblesort at bubblesort.c:6
```

**设置断点生效**

ena/enable	断点编号

**设置条件断点(一般用在循环的位置)**

b/break	10	if	i==5

#### 1.5.5 调试命令

**运行GDB程序**

start	(程序停在第一行)

run	  (遇到断点才停)

**继续运行，到下一个断点停**

c/continue

**向下执行一行代码(不会进入函数体)**

n/next

**变量操作**

p/print	变量名(打印变量值)

ptype	  变量名(打印变量类型)

**向下单步调试(遇到函数进入函数体)**

s/step

finish（跳出函数体）

**自动变量操作**

display	num（自动打印指定变量的值）

i/info	display（查看设置的自动变量操作)

undisplay	编号	(删除设置的自动变量)

**其他操作**

set    var   变量名=变量值

until（跳出循环）

### 1.6 标准 C 库IO和Linux系统IO的区别

1、标准C库IO

例子：fopen   fclose    fread    fwrite   ...........  这些函数的底层是调用了Linux系统IO的函数 ，例如 read  write

可跨平台

缓冲区 -> 文件   ：即数据从内存刷新到磁盘

这个过程：1、刷新缓冲区:  fflush  函数   2、缓冲区已满   3、正常关闭文件

效率高：标准C库IO是带缓冲区的，默认的缓冲区大小  8192 byte

### 1.7  虚拟地址空间

下图示例为 32bit 的操作系统

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%B8%80%E7%AB%A0_Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)

### 1.8 文件描述符

文件描述符保存在内核区，有PCB(进程控制块)通过文件描述符表进行管理，每个进程拥有一个文件描述符表，文件描述符表是一个数组，默认的大小为 1024 。

每个文件描述符表：

默认已打开前三个文件描述符：

标准输入:		0 ->  STDIN_FILENO

标准输出:		1 ->  STDOUT_FILENO

标准错误：	 2 ->  STDERR_FILENO

这三个文件描述符都对应同一个终端：/dev/tty

### 1.9 Linux系统 IO 函数

**open 函数**

```c
int fd = open("open.c" , O_RDWR | O_CREAT , 0777 );
//  第三个参数mode 指定 被创建文件的权限  实际上结构是 0775(mode & umask)  umask : 0002
```

**lseek 函数**

```c
off_t lseek(int fd, off_t offset, int whence);
/*
	返回值：文件指针的位置
	参数：whence
		 SEEK_SET
		 	设置文件指针的偏移量
          SEEK_CUR
             设置偏移量：当前位置 + 第二个参数 offset
          SEEK_END
             设置偏移量：文件大小 + 第二个参数 offset
*/
/*
	该函数主要用于：
		1、移动文件指针到文件头
		lseek(fd, 0, SEEK_SET);
		2、获取当前文件指针的位置
		lseek(fd, 0, SEEK_CUR);
		3、获取文件的大小
		lseek(fd, 0, SEEK_END);
		4、拓展文件的长度，例如 10b -> 110b
		lseek(fd, 100, SEEK_END);
		移动指针后需要写入一个空数据：write(fd , " " , 1);
*/
```

**stat 和 lstat 函数**

stat 

```shell
[dzl@localhost lession6_Linux文件IO]$ stat open.c 
  文件：open.c
  大小：0               块：0          IO 块：4096   普通空文件
设备：fd02h/64770d      Inode：50455829    硬链接：1
权限：(0775/-rwxrwxr-x)  Uid：( 1000/     dzl)   Gid：( 1000/     dzl)
最近访问：2021-11-10 20:49:08.355865686 +0800
最近更改：2021-11-10 20:49:08.355865686 +0800
最近改动：2021-11-10 20:49:08.355865686 +0800
创建时间：2021-11-10 20:49:08.355865686 +0800
```

```c
int stat(const char *pathname, struct stat *statbuf);
/*
	作用：获取一个文件的相关信息
	参数：struct stat *statbuf
	statbuf：结构体指针变量，传出参数，用于保存获取的文件信息
*/
```

stat 结构体的各个成员变量

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%B8%80%E7%AB%A0_Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/stat%E7%BB%93%E6%9E%84%E4%BD%93.png)

其中比较重要的一个成员变量：st_mode

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%B8%80%E7%AB%A0_Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8/st_mode%E5%8F%98%E9%87%8F.png)

lstat 

```c
int lstat(const char *pathname, struct stat *statbuf);
该函数参数与 stat 一样，这个函数用于获取软连接文件的信息
```

```shell
ln -s open.c lopen.c
```

为open.c 函数创建一个软连接文件lopen.c

```shell
[dzl@localhost lession6_Linux文件IO]$ ln -s open.c lopen.c
[dzl@localhost lession6_Linux文件IO]$ ll
总用量 24
lrwxrwxrwx 1 dzl dzl     6 十一月 10 22:13 lopen.c -> open.c
-rwxrwxr-x 1 dzl dzl 17584 十一月 10 20:49 main
-rw-rw-r-- 1 dzl dzl   338 十一月 10 22:10 main.c
-rwxrwxr-x 1 dzl dzl     0 十一月 10 20:49 open.c
```

## 第二章 linux多进程开发

### 2.1 进程概述

#### 2.1.1 时间片

在Linux上CPU为每个进程分配的时间 为 5ms - 800ms

首先，内核为所有的进程分配相等的初始化时间片，当所有进程都消耗掉时间片后，内核再重新为每个进程进行分配时间片，如此往复。

#### 2.1.2 并行、并发

并行：同一个时刻有多条指令在多个处理器上执行

并发：同一时刻只有一条指令执行，多个进程指令快速的轮番执行。

#### 2.1.3 进程控制块

内核为每个进程分配了一个 PCB(processing  control  block)进程控制快，维护进程相关信息，Linux的内核控制块是 task_struct 结构体。

### 2.2 进程的状态转换

#### 2.2.1 进程的状态

三态模型：就绪态，运行态，阻塞态

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81_%E4%B8%89%E6%80%81.png)

五态模型：新建态，就绪态，运行态，阻塞态，终止态

#### 2.2.2 进程相关命令

查看进程

ps  aux / ajx

a：显示终端上的所有进程，包括其它用户的进程

u：显示进程的详细信息

x：显示没有控制终端的进程

j：列出与作业控制相关的信息

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B_%E7%8A%B6%E6%80%81%E5%8F%82%E6%95%B0.png)

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E5%AE%9E%E6%97%B6%E6%98%BE%E7%A4%BA_%E8%BF%9B%E7%A8%8B%E5%8A%A8%E6%80%81.png)

### 2.3  创建进程

#### 2.3.1 进程创建

系统允许一个进程创建新进程，即创建子进程，子进程也可以创建新的子进程，形成进程树结构类型。

##### 父子进程的虚拟地址空间

Linux的fork()函数采用 **写时拷贝(copy -on- write)** 实现

写时拷贝：

父子进程在对地址空间的读操作上，是共享的，子进程共享父进程，但是一旦父进程或者子进程有写的操作，就会复制 新的物理内存。如此来提高效率且不冲突。

##### 父子进程的关系

区别：

1、fork()函数的返回值：父进程返回的是子进程的PID，子进程返回的是0

2、pcb中的一些数据

​			当前进程的 ID ，pid

​			当前进程的父进程id和ppid

​			信号集

共同点：

​	某些状态下：子进程被创建出来，还没有执行写操作时

 - 用户去的数据
 - 文件描述符表

父子进程之间对变量是不是共享的：

1、刚开始的时候，是一样的，共享的。如果修改了数据，就不共享了。总结为 ：读时共享，写时拷贝

#### 2.3.2 GDB多进程调试

GDB调试默认跟踪的是父进程，可以在fork函数调用之前，使用指令设置 GDB 调试工具追踪父进程或者子进程。

1、设置跟踪父子进程的指令：

set  follow-fork-mod  [parent(默认) | child]

2、设置其他指令是否脱离GDB的指令：

set  detach-on-fork  [on(默认) | off]

默认为on，即表示调试当前进程的时候，其他的进程继续运行，如果为off，调试当前进程的时候，其他进程被GDB挂起。

3、查看调试的进程编号

info  inferiors

4、切换当前调试的进程

inferior  id

5、使进程脱离 GDB 调试

detach  inferiors  id

### 2.4 exec 函数族

#### 2.4.1 介绍

exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容。换句话说，就是在调用进程内部执行一个可执行文件。

执行成功后不会返回，失败返回-1

exec 函数一般用于子进程调用

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/exec%E5%87%BD%E6%95%B0%E6%97%8F.png)

### 2.5 进程退出、孤儿进程、僵尸进程

#### 2.5.1 进程退出

标准 C 库里函数：

```c
#include <stdlib.h>
void  exit( int status );
```

Linux环境函数：

```c
#include <unistd.h>
void _exit( int status );
```

两者的实现过程：

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/exit%E4%B8%8E_exit%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png)

大多情况都会使用标准C库的 exit函数

#### 2.5.2 孤儿进程

概述：父进程运行结束，但子进程还在运行，即称为孤儿进程

孤儿进程回收过程：每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ， 二 init 进程会循环地 wait() 它的子进程退出。所以即 init 来处理孤儿进程的善后工作。

init 进程的pid为 1 ， 即系统的第一个进程。

因此，孤儿进程并不会有什么危害。

#### 2.5.3 僵尸进程

概述：每个进程结束之后，都会释放自己地址空间中的用户区数据，内核去的 PCB 没有办法自己释放掉，需要父进程去释放。进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸(Zombie)进程。

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.png)

### 2.6 wait 、waitpid 函数

wait 和 waitpid 函数功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞。

一次 wait 或者 waitpid 只能清理一个子进程，清理多个使用循环。

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%8F%82%E6%95%B0.png)



### 2.7 进程间通信

进程间通信( IPC: Inter  Processes Communication )

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1.png)

#### 2.7.1 匿名(无名)管道

举例：统计一个目录中文件的数目命令：ls  |  wc  -l  ，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E6%97%A0%E5%90%8D%E7%AE%A1%E9%81%93.png)

**管道的特点：**

1、管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。

2、管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，单不存储数据。可以按照操作文件的方式对管道进行操作。

3、一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。

4、通过管道传输的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。

5、在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道时半双工的。

6、从管道读数据时一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。

7、匿名管道只能在具有公共祖先的进程(父进程与子进程，或者两个兄弟进程，具有亲缘关系)之间的使用。

**管道的数据结构为：环形队列**

#### 2.7.2 管道读写的特点

以下情况为阻塞型管道

1、写端全部关闭，read 返回0(相当于读到文件末尾)。

2、读端全部关闭 ，对管道进行write的进程会收到一个信号 SIGPIPE，通常会导致进程异常终止。

3、管道中缓冲数据已满，write则会阻塞

#### 2.7.3 有名管道

与匿名管道不同点：

1、FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中

2、当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用

3、FIFO 有名字，不相关的进程可以通过打开有名管道进行通信

**如何使用**

1、key通过命令创建有名管道

mkfifo   名字

2、通过函数创建有名管道，FIFO 和普通文件一样，但不支持 lseek()等文件定位操作。

### 2.8 内存映射

注意事项：

1、调用mmap函数时，设置文件的偏移量为 1000 会怎么样？

答：失败 ，返回MAP_FAILED ， 因为偏移量必须死 4K 的整数倍。

2、mmap函数什么情况下会调用失败？

答：

 - 第二个参数：length = 0
 - 第三个参数：port 
    - 只定义了写权限
    - 定义的权限 > fd在打开文件时的权限

3、可以open的时候O_CREAT一个新文件来创建映射区吗？

 - 可以 ， 但是创建的文件的大小如果为 0 的话，肯定不行

   所以需要对新的文件进行扩展

   - lseek()
   - truncate()

### 2.9 信号集及相关函数

信号的特点

- 简单
- 不能携带大量信息
- 满足某个特定条件才发送
- 优先级比较高

查看系统定义的信号列表：kill   -l

前 31 个信号为常规信号，其余为实时信号

**信号的5种默认处理动作**

- 查看信号的详细信息：man  7  signal

- 信号的 5 种默认处理动作

  - Term		终止进程

  - Ign           当前进程忽略掉这个信号

  - Core        终止进程，并生成一个Core文件

  - Stop        暂停当前进程

  - Cont        继续执行当前被暂停的进程

    

信号的几种状态：产生、未决、递达

SIGKILL 和  SIGSTOP  信号不能被捕捉、阻塞或者忽略，只能执行默认动作。

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png)

信号集：

1、用户通过键盘 Ctrl  +  C ，产生 2 号信号SIGINT（信号被创建）

2、信号产生但是没有被处理（未决）

 - 在内核中将所有的没有被处理的新号存储在一个集合中（未决信号集）

 - SIGINT信号状态被存储在第二个标志位上

    - 标志位为 1 ，信号处于未决状态

    - 标志位为 0 ，信号不是未决状态

      

3、未决信号需要被处理，未决信号集通过查看比较阻塞信号集的信号阻塞状态，来判断

信号是否被发送给进程处理，进而判断信号的状态是未决或非未决，从而判断是否修改未决标志位。

	- 阻塞信号集默认不阻塞所有信号
	- 如果想要阻塞某个信号需要用户调用系统的API

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E4%BA%8C%E7%AB%A0_Linux%E5%A4%9A%E8%BF%9B%E7%A8%8B/%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7_%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png)

### 2.10 共享内存 （效率最高的进程间通信）

概述：

共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。

**共享内存使用步骤：**

1、shmget() 创建一个新的共享内存段 或 获取一个已存在的共享内存段 ，返回共享内存标识符

2、shmat() 设置共享内存段成为调用进程的虚拟内存的一部分，返回值为共享内存段的首地址

3、shmdt() 分离共享内存段，该函数是可选的，进程结束时会自动调用该函数

4、shmctl() 操作共享内存段(主要用于删除)，只有当所有附加内存端的进程与之分离之后，才会销毁，只有一个进程需要执行这一步。

**思考问题**

1、操作系统如何知道一块共享内存被多少个进程关联？

 -	共享内存维护了一个结构体 struct shmid_ds ，该结构体有一个成员 shm_nattch
 -	shm_nattch 记录了关联的进程个数

2、共享内存和内存映射的区别

 - 共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外，但匿名映射只能用于有亲缘关系的进程)

 - 共享内存效率更高

 - 内存映射所有的进程操作的都是同一块共享内存，而内存映射，每个进程在自己的虚拟地址空间中有一块独立的内存

 - 数据安全

   - 进程突然退出

     共享内存还存在

     内存映射区消失

   - 运行进程的电脑死机，宕机了

     存在共享内存中的数据，没有了

     存在内存映射区的数据，由于磁盘文件还存在，数据还存在

     

- 生命周期

  - 内存映射区：进程退出，内存映射区销毁

  - 共享内存：进程退出，共享内存还在，标记删除(关联的所有进程数为0)，或者关机

     如果进程退出，会自动取消关联

### 2.11 守护进程

概述：

守护进程（Daemon Process），也称之为 Daemon 进程（精灵进程），是Linux中的后台服务进程。一般采用 d 结尾的名字。

守护进程的特征：

1、生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。

2、它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号，如（SIGINT 、SIGQUIT）。

Linux 的大多数服务器就是用守护进程实现的。比如，Internet   服务器 inetd ，Web 服务器 httpd 等。

**守护进程的创建步骤**

1、执行一个 fork()，之后父进程退出，子进程继续执行

2、子进程调用 setsid() 开启一个新会话

3、清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限

4、修改进程的当前工作目录，通常会改为根目录（/）

5、关闭守护进程从其父进程继承而来的所有打开着的文件描述符

6、关闭了文件描述符 0、1、2 之后，守护进程通常会打开/dev/null  并使用 dup2()重定向 文件描述符 0、1、2，使其指向/dev/null 设备，在该设备上打印信息会被系统丢弃。

7、核心业务逻辑

## 第三章 Linux多线程

### 3.1 线程概述_创建线程

#### 概述

1、进程是 CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。

2、线程是轻量级的进程（LWP:Light  Weight  Process) ,在Linux环境下线车的本质仍是进程

3、查看指定进程的 LWP 号： ps  -Lf    pid

#### 创建线程

一般情况下，main函数所在的线程称之为 主线程 ， 其余创建的线程称之为子线程。

### 3.2 互斥锁

一旦线程锁定互斥量，随机成为该互斥量的所有者，只有所有者才能给互斥量解锁。

### 3.4 条件变量

条件变量不是锁，它可以阻塞线程，当满足某个条件后解除阻塞

### 3.5 读写锁

特点：

1、当线程读数据，则允许其他线程执行读操作，但不允许写操作

2、当线程写数据，则其它线程都不允许读、写操作

3、写是独占的，写的优先级高

读写锁的效率比 互斥锁更高

### 3.6 生产者和消费者模型

组成部分：

1、生产者

2、消费者

3、容器

关系：

1、生产者和消费者，都共用着容器，这里需要对容器加锁

2、当容器没有任务，消费者需要提醒生产者生产，当生产者产生了任务到容器，需要提醒消费者消费，这里需要线程之间的通信，条件变量、信号量。



## 第 四 章  Linux网络编程

### 4.1 网络结构模式

#### C/S结构

##### 简介

客户机-服务器 ， 即 Client - Sever 结构

#### B/S 结构

##### 简介

Browser/Sever , 浏览器/服务器模式，

### 4.2 MAC地址  IP地址

#### MAC地址

MAC地址（Media  Access  Control  Address），直译媒体存取控制位址，也称为局域网地址、以太网地址、物理地址和硬件地址。它是一个用来确认网络设备位置的位址。

​	在OSI模型中，第三层网络层负责 IP 地址，第二层数据链路层负责MAC 位址。

##### 唯一性

MAC地址的长度为 48位（6个字节），如 00-16-EA-AE-3C-40 ,其中前 3 个字节，00-16-EA 代表网络硬件制造商的编号，由 IEEE 协会提供，而后 3 个字节，AE-3C-40 ， 代表制造商所制造的某个网络产品的系列号，理论上，MAC地址就像身份证一样，全球都是唯一的。

所以，可以通过MAC地址，找到网卡硬件设备。

#### IP 地址

IP （Internet  protocol  Address）地址是指互联网协议地址，属于逻辑地址，虚拟的。

IP 由 4个字节 32位 组成，通常用 点分十进制 形式表示，

##### IP地址编址方式

IP地址分为 A ~ E 五类

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png)

###### A类地址

由一个 字节的网络地址 和 3 个字节的主机地址组成，网络地址的最高位必须是 “0” ， 所以有 126 个网络 。

A类 IP地址的子网掩码为 255.0.0.0 ， 每个网络支持的最大主机数为 256 的3次方  - 2 = 16777214。

其它类型地址 请看课件....

###### 特殊的网址

IP地址中不能以十进制 “127” ，作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测试，如：127.0.0.1 可以代表本机 IP 地址。

#### 子网掩码

子网掩码只有一个作用，就是将某个IP地址划分为网络地址和主机地址两部分。用于屏蔽 IP 地址的一部分以区别网络标识和主机标识。并说明该 IP 地址是在局域网上还是广域网上。

比如 C类地址的子网掩码：255.255.255.0

#### 端口

##### 简介：

物理端口又称为接口，TCP/IP协议中的端口为逻辑端口（虚拟的）。

端口由 2 个字节组成，所以一个 IP 地址可以有 端口号的范围为 0 ~ 65536 。端口号可以标识进程，通过端口号可以找到进程，端口也是在TCP/IP通讯中起到了缓冲区的作用。

##### 端口类型

###### 周知端口

绑定某些服务的端口，例如 80 端口分配给 WWW 服务，21 端口分配给 FTP服务，23 端口分配给 Talnet 服务等等。

###### 注册端口

应用程序一般使用该类型端口好 ， 端口号从 1024 到 49151。

### 4.3 网络模型

#### 七层参考模型 OSI

#### TCP/IP 四层模型

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP_IP%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B.png)

### 4.4 协议

#### 常见协议

##### 应用层常见协议：

FTP 协议（File Transfer  Protocol 文件传输协议）、HTTP 协议（Hyper  Text  Transfer Protocol 超文本传输协议）、NFS （Network  File  System 网络文件系统）。

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B_%E7%9B%B8%E5%85%B3%E5%8D%8F%E8%AE%AE.png)

#### UDP协议

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/UDP%E5%8D%8F%E8%AE%AE.png)

#### TCP协议

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E5%8D%8F%E8%AE%AE%E6%A1%86%E6%9E%B6%E5%9B%BE.png)

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86.png)

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E7%BB%86_2.png)

#### IP 协议

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IP%E5%8D%8F%E8%AE%AE.png)

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/IP%E5%8D%8F%E8%AE%AE_2.png)

#### ARP 协议

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/ARP%E5%8D%8F%E8%AE%AE.png)

### 4.5 网络通信的过程

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B_%E5%B0%81%E8%A3%85.png)

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B_%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

#### ARP通信过程

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/arp%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85.png)

### 4.6 Socket

套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进程通信的接口，是应用程序与网络协议根进行交互的接口。

socket 由 IP 和 端口结合的，提供向应用层进程传送数据包的机制。

### 4.7  字节序

#### 概述

字节序，分为大端字节序和小端字节序。

小端字节序：高位地址存高位字节，低位地址存低位字节

大端字节序：高位地址存低位字节，低位地址存高位字节

绝大部分计算机：

小端字节序

#### 字节序转换函数

为了解决可能存在的不同 机型的通信时数据解析问题，

行业规定：发送端在发送时，总是先把数据转换成大端字节序数据后再发送，接收端根据自身的字节序判断是否需要进行转换。

所以，网络字节序即为大端，主机字节序则根据机型而分。

```c
/*
h   --  host 主机，主机字节序
to  --  转换
n   --  network 网络字节序
s   --  unsigned  short 
l   --  long == unsigned int
*/
#include <arpa/inet.h>
//转换端口
uint16_t htons(uint16_t hostshort);  //主机字节序 -》 网络字节序
uint16_t ntohs(uint16_t netshort);   //网络字节序 -》 主机字节序
//转换 IP
uint32_t htonl(uint32_t hostlong);   //主机字节序 -》 网络字节序
uint32_t ntohl(uint32_t netlong);    //网络字节序 -》 主机字节序

```

### 4.8 socket地址

```c
/*
socket地址是一个结构体，封装端口号和IP等信息
socket网络编程中表示socket地址的是结构体sockaddr，其定义如下：
struct  sockaddr{
	sa_family_t  sa_family;
	char         sa_data[14];
};
typedef  unsigned  short  int  sa_family_t;
*/
上面的结构体编程时不适合编辑，目前主流使用下面的 sockaddr_in 地址结构体
/*
include <netinet/in.h>
struct sockaddr_in
{
	sa_family_t  sa_family;    /*__SOCKADDR_COMMON (sin_);*/
    in_port_t sin_port;            /* Port number.  */
    struct in_addr sin_addr;        /* Internet address.  */
    /* Pad to size of `struct sockaddr'.  */ //用来字节的
    unsigned char sin_zero[sizeof (struct sockaddr) - __SOCKADDR_COMMON_SIZE -
                     sizeof(in_port_t) - sizeof(struct in_addr)];
}; 
*/
```

### 4.9 IP 地址转换函数（字符串ip - 整数，主机、网络字节序的转换）

```c
#include <arpa/inet.h>
/*
p:点分十进制的IP字符串
n：表示network，网络字节序的整数
*/
//功能：将点分十进制的IP字符串，转换为网络字节序的整数
/*
参数：
af：协议族：AF_INET or AF_INET6
src：需要转换的点分十进制的IP字符串
dst：转换后的结果保存在这里面
*/
int inet_pton(int af, const char *src, void *dst);

/*
功能：将网络字节序的整数，转换为点分十进制的IP字符串
参数：
af：协议族：AF_INET or AF_INET6
src：需要转换的网络字节序的整数
dst：转换后的IP字符串的首地址
size：dst字符串的长度
返回值：
返回转换后的字符串的首地址，和dst是同一个值。
*/
const char *inet_ntop(int af, const void *src,
                             char *dst, socklen_t size);

```

### 4.10 TCP 通信流程

```c
//TCP 和 UDP    --- 传输层的协议
UDP：
    用户数据报协议
    面向无连接，可以单播、多播、广播，面向数据报，不可靠
TCP：
    传输控制协议
    面向连接的，可靠的，基于字节流的传输协议，仅支持单播传输，即点对点传输
```

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\TCP通信流程图.png)

### 4.11 socket 函数

```c
#include <sys/types.h>      
#include <sys/socket.h>
#include <arpa/inet.h>	//包含了这个头文件，上面两个就可以省略
int socket(int domain, int type, int protocol);
-功能：创建一个套接字
-参数：
    domain：协议族
    	AF_INET ：ipv4
    	AF_INET ：ipv6
    	AF_UNIX ，AF_LOCAL ：本地套接字通信(进程间通信)
    type：通信过程中使用的协议类型
   		SOCK_STREAM：流式协议
    	SOCK_DGRAM ：报式协议
    protocol：具体的一个协议，一般写 0 
    	SOCK_STREAM：流式协议 ， 默认使用 TCP
    	SOCK_DGRAM ：报式协议 ， 默认使用 UDP
-返回值
    成功：返回文件描述符，操作的是内核缓冲区。
   	失败：返回 -1
int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
功能：绑定，将fd和本地的 IP 、端口号进行绑定
参数：
    sockfd：使用socket函数，得到的文件描述符
    addr：需要绑定的socket地址，这个地址封装了ip和端口的信息
    addrlen：第二个参数结构体占的内存大小
int listen(int sockfd, int backlog);
功能：监听这个socket上的连接
参数：
    sockfd：socket函数得到的文件描述符
    backlog：（listen在底层有两个队列，一个为未连接队列，一个为已连接队列）
    	未连接和已连接的和的最大值，一般这个值取 5 ，够用了。
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接
参数：
    sockfd：socket函数得到的文件描述符
    addr：需要绑定的socket地址，这个地址封装了ip和端口的信息
    addrlen：第二个参数结构体占的内存大小的指针
返回值：
    成功：返回用于通信的文件描述符
    失败：-1
int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);
功能：客户端连接服务器
参数：
    sockfd：通讯的文件描述符，客户端是由socket函数产生
    addr：需要绑定的socket地址，这个地址封装了ip和端口的信息
    addrlen：第二个参数结构体占的内存大小
返回值：
    成功：0
    失败：-1
ssize_t write(int fd, const void *buf, size_t count);
ssize_t read(int fd, void *buf, size_t count);
```

### 4.12 TCP 三次握手

```c
TCP可以看成是一种字节流，它会处理 IP 层或以下的层的丢包、重复以及错误的问题。
三次握手发生在客户端连接connect的时候
/*
第一次握手：
	1、客户端将SYN标志位置为 1 
	2、生成一个随机的 32 位的序号 seq = J，这个序号后续是可以携带数据(数据的大小)
第二次握手：
	1、服务器端接收客户端的连接：ACK标志位置为 1
	2、服务器回发一个确认序号：  ack = 客户端的序号 + 数据长度 + SYN/FIN（按一个字节来算）
	3、服务器端会向客户端发起连接请求：SYN 置为 1
	4、服务器端会生成一个随机序号：seq = K
第三次握手：
	1、客户端应答服务器的连接请求：ACK 置为 1
	2、客户端回复收到了服务器的数据，即确认序号：ack = 服务端的序号 + 数据长度 + SYN/FIN（按一个字节来算）
*/
```

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%97%B6%E5%BA%8F%E5%9B%BE.png)

```c
/*
SYN 为连接标记位 ， ACK 为确认标记位
seq 为序号	 ack 为确认序号  ，序号的随机生成是有算法的，可深入了解
只有当ACK为1时，ack才有用
*/
```

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

### 4.13 滑动窗口

```c
滑动窗口（Sliding  window）是一种流量控制技术。

滑动窗口协议是用来改善吞吐量的一种技术，即容许发送方在接收任何应答之前传送附加的包。接收方告诉发送方在某一时刻能送多少包(称窗口尺寸)。

当滑动窗口为0时，发送方一般不能再发送数据段。
```

![滑动窗口](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\滑动窗口.png)

```c
发送方的缓冲区：
    白色格子：空闲的空间
    灰色格子：数据已经发送出去，但是没有收到接收方的确认
    红色格子：未发送的数据
接收方的缓冲区：
    白色格子：空闲的空间
    红色格子：接收到的数据
```

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\滑动窗体的具体通信过程.png)

```c
# mss：Maximum  Segment   Size（一条数据的最大的数据量）
# win：滑动窗口
1、客户端向服务器发起连接，客户端的滑动窗口大小为 4096 ， 一次发送的最大数据量为 1460
2、服务器接收连接请求，告诉客户端服务器的窗口大小为 6144 ， 一次发送的最大数据量为 1024
3、第三次握手
4、4 - 9 客户端连续给服务器发送了 6K 的数据，每次发送 1K
5、 第10次，服务器告诉客户端：发送的 6K 数据已经接收到了，存储在缓冲区中，缓冲区数据已经处理了 2K ， 窗口大小为 2K
6、 第10次，服务器告诉客户端：发送的 6K 数据已经接收到了，存储在缓冲区中，缓冲区数据已经处理了 4K ， 窗口大小为 4K
7、 第12次，客户端给服务器发送了 1K 的数据，
8、 第13次，第一次挥手，客户端主动请求和服务器断开连接，并且给服务器发送了 1K 的数据
9、 第14次，第二次挥手，服务器回复ACK：8194，同意断开连接，告诉客户端接收到了 1K 数据，滑动窗口为：2K
10、第15次、16次，通知客户端滑动窗口的大小
11、第17次，第三次挥手，服务器给客户端发送FIN，请求断开连接
12、第18次，客户端同意了服务器的断开请求
```

### 4.14 TCP 四次挥手

### 4.15 TCP 状态改变

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E7%8A%B6%E6%80%81%E6%94%B9%E5%8F%98.png)

**为了使得四次挥手能够完整**

2MSL （Maximum  Segment  Lifetime）

主动断开连接的一方，最后进入一个 TIME_WAIT 状态，这个状态会持续：2msl

msl：官方建议：2分钟，实际是 30s

因为如果最后一个 ACK，出现丢失，被关闭方就会重发 FIN ，所以主动断开连接方需要等待2MSL 时间

### 4.16 半关闭、端口复用

#### 4.16.1 半关闭

**半关闭状态**：能够接收数据，但是不能发送数据

通信双方：某一方发送了请求关闭的FIN后，就开始处于半关闭状态，知道完整的四次挥手完成后，半关闭状态才结束

从程序的角度，可以通过使用API来控制实现半关闭状态。

```c
#include <sys/socket.h>
int shutdown(int sockfd, int how);
参数：how
    SHUT_RD,  SHUT_WR,  SHUT_RDWR  have  the  value  0,  1,  2
```

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/shutdown%E5%87%BD%E6%95%B0_%E5%A5%97%E6%8E%A5%E5%AD%97%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0.png)

#### 4.16.2 端口复用

查看网络相关信息的命令

netstat

参数：

-a	所有的socket

-p	显示正在使用socket的程序的名称

-n	直接使用IP地址，而不通过域名服务器

```shell
netstat -anp | grep 9999
```

端口复用：

- 防止服务器重启时之前绑定的端口还未释放
- 程序突然退出而系统没有释放端口

```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>
int setsockopt(int sockfd, int level, int optname,
                      const void *optval, socklen_t optlen);
功能：
    设置套接字
参数：
    sockfd：要操作的文件描述符
    level：级别
    	SOL_SOCKET	端口复用在这个级别
    optname：选项的名称
    	SO_REUSEADDR
    	SO_REUSEPORT
	optval：端口复用的值
    	1：可以复用
    	0：不可以复用
	optlen：optval参数的大小
/*
端口复用设计的时机：
    服务器绑定端口之前。
*/    

```

### 4.17 I/O多路复用（I/O多路转接）

I/O多路复用使得程序能同时监听多个文件描述符，能够提高程序的性能。

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\BIO模型.png)

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\select_poll技术简介.png)

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\epoll技术简介.png)

#### select

主旨思想：
1、构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中

2、调用一个系统函数，监听该列表中的文件描述符，直到这些文件描述符中的一个或者多个进行I/O操作时，该函数才返回。

​	a.这个函数是阻塞的

​	b.函数对文件描述符的检测的操作是由内核完成的

3、在返回时，会告诉进程有多少描述符要进行I/O操作

```c
#include <sys/select.h>
/* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, struct timeval *timeout);
	参数：
        nfds：委托内核监测的最大文件描述符数的值 + 1 /*因为内核的文件描述符遍历数组是从 0 开始的*/
        readfds：要监测的文件描述符的读的集合，委托内核监测哪些文件描述符的读的属性
        	- 一般监测读操作
        	- 对应的是对方发送过来的数据，因为读是被动的接收数据，监测的就是读缓冲区。
        	- 是一个传入传出参数
    	writefds：要监测的文件描述符的写的集合，委托内核监测哪些文件描述符的写的属性
        	- 委托内核监测写缓冲区是不是还可以写数据(缓冲区没满就可以写)
        exceptfds：监测发生异常的文件描述符的集合
        timeout：设置监测超时的时间
        	struct timeval {
               long    tv_sec;         /* seconds */
               long    tv_usec;        /* microseconds */
           	};
			- NULL ：永久阻塞，直到监测到了文件描述符有变化
             - tv_sec = 0  tv_usec = 0，不阻塞
             - tv_sec > 0  tv_usec > 0, 阻塞对应的时间
	返回值：
        失败：-1
        成功：监测文件描述符集合中发生变化的个数
/*将参数文件描述符 fd ，对应的标志位设置为 0 */
void FD_CLR(int fd, fd_set *set);
/*返回参数fd ， 在集合中的标志位 ， 0或1*/
int  FD_ISSET(int fd, fd_set *set);
/*设置 参数fd 在集合中对应的标志位为 1*/
void FD_SET(int fd, fd_set *set);
/*清空集合中所有的文件描述符 置为 0*/
void FD_ZERO(fd_set *set);
```

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\select的工作过程.png)

#### poll

**select 的缺点：**

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%AC%AC%E5%9B%9B%E7%AB%A0_Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/select%E7%9A%84%E7%BC%BA%E7%82%B9.png)

```c
#include <poll.h>
struct pollfd {
    int   fd;         /* 委托内核监测的 file descriptor */
    short events;     /* 委托内核检测文件描述符的事件requested events */
    short revents;    /* 文件描述符实际发生的事件 returned events */
};
int poll(struct pollfd *fds, nfds_t nfds, int timeout);
	参数：
        fds：struct pollfd 类型的结构体数组的首地址
	    nfds：参数fds数组中，最后一个有效元素的小标 + 1
        timeout：阻塞时长
        	0:不阻塞
            -1:阻塞，当监测到变化后，解除阻塞
            >0:阻塞的时长，单位为ms
	返回值：
        -1：失败
        >0：成功，返回监测数组中，发生变化的数目
```

#### epoll

epoll多路复用

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\epoll多路复用.png)

```c
#include <sys/epoll.h>
/*创建一个新的epoll实例：在内核中创建一个结构体数据，该结构体中有两个主要成员，1、需要监测的文件描述符的信息(红黑树存储)，2、就序列表，存放监测到数据改变的文件描述符信息(双向链表)*/
int epoll_create(int size);
	参数：
        size：目前没有意义。随便写一个数。必须大于0。因为以前是用哈希实现，目前的计数不需要了。
	返回值：
        失败：-1
        成功：返回文件描述符，用来操作epoll实例
/*对epoll实例进行操作: 增、删、改 */
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
	参数：
        epfd：epoll实例对应的文件描述符
        op：对epoll实例进行的操作
        	EPOLL_CTL_ADD：添加
        	EPOLL_CTL_MOD：修改
        	EPOLL_CTL_DEL：删除
        fd：要监测的文件描述符
        event：设置监测的文件描述符的事件
       		 struct epoll_event {
               uint32_t     events;      /* Epoll events */
               epoll_data_t data;        /* User data variable */
           		};
			常见的epoll监测事件：
                EPOLLIN
                EPOLLOUT
                EPOLLERR
            typedef union epoll_data {
               void        *ptr;
               int          fd;
               uint32_t     u32;
               uint64_t     u64;
             } epoll_data_t;
/*监测函数*/
int epoll_wait(int epfd, struct epoll_event *events,
                      int maxevents, int timeout);
	参数：
        epfd：epoll实例对应的文件描述符
        events：传出参数，保存了发生变化的文件描述符的信息
        maxevents：第二个参数，结构体数组的大小
        timeout：阻塞时间
        	0：不阻塞
        	-1：阻塞，直到监测到变化
        	>0：阻塞的时长，单位 ms
	返回值：
        成功：返回发生变化的文件描述符的个数
        失败：-1
```

### 4.18 epoll的两种工作模式

#### 4.18.1 LT模式（水平触发）

LT（level  triggered）即缺省的工作方式(默认)，同时支持 block 和 no-block socket。当用户没有对就绪的fd进行I/O操作，内核还是会继续通知用户。

```c
/*
当epoll监测到有事件发生：
	只要发生事件的文件描述符的数据 没有被完全读取完。
	epoll都会不断通知，直到数据读取完为止。
*/
```



#### 4.18.2 ET模式（边沿触发）

ET（edge  triggered）即高速工作模式，只支持 no-block socket，在这种模式下，当描述符从未就绪变为就绪态，内核自会通知一次(only  once)。

ET模式减少了epoll事件被重复触发的次数，效率较高，改模式下用户必须使用非阻塞接口。

```c
/*
当epoll监测到有事件发生：
	不管发生事件的文件描述符的数据 有没有 被完全读取完。
	epoll都不会继续通知。
*/

struct epoll_event {
    uint32_t     events;      /* Epoll events */
    epoll_data_t data;        /* User data variable */
};
常见的epoll监测事件：
    EPOLLIN
    EPOLLOUT
    EPOLLERR
    EPOLLET					//设置为 ET 模式，需要在设置触发事件时 | EPOLLET
```

### 4.19 UDP通信实现

```c
/*
	UDP 协议专属的API
*/
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
	参数：
        sockfd：通信的fd
        buf：要发送的数据
        len: 发送数据的数据长度
        flags: 0
	    dest_addr:通信的另一端的地址信息
		addrlen:地址的内存大小
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                        struct sockaddr *src_addr, socklen_t *addrlen);
	参数：
        sockfd：通信的fd
        buf：接收数据的数组
        len：数组的大小
        flags：0
        src_addr：用来保存另外一端的地址信息，不需要可以指定为NULL
        addrlen：地址的内存大小
```

### 4.20 广播

向子网中多台计算机发送消息，并且子网中所有的计算机都可以接受到发送方发送的消息，每个广播消息都包含一个特殊的IP地址，这个IP中子网内主机标志部分的二进制全部为 1。

特性：

a.只能在局域网中使用

b.客户端需要绑定服务器广播使用的端口，才可以接受到广播消息

```c
/*设置套接字广播属性函数*/
int setsockopt(int sockfd, int level, int optname,
                      const void *optval, socklen_t optlen);
	参数：
        sockfd：文件描述符
        level：SOL_SOCKET
        optname：SO_BROADCAST
        optval：int类型的值，为1表示允许广播
        optlen：optval的大小
```

### 4.21 组播(多播)

特性：

组播可以用于局域网，也可以用于广域网

客户端需要加入多播组，才能接受到多播的数据

```c
/*设置套接字 组播 属性函数*/
int setsockopt(int sockfd, int level, int optname,
                      const void *optval, socklen_t optlen);
//服务器设置多播信息，外出接口：
	level：IPPROTO_IP
	optname：IP_MULTICAST_IF
	optval：struct  in_addr
//客户端加入到多播组
	level：IPPROTO_IP
	optname：IP_ADD_MEMBERSHIP
	optval：struct  ip_mreq
struct ip_mreq
  {
    /* IP multicast address of group.  */
    struct in_addr imr_multiaddr;	//多播的IP地址

    /* Local IP address of interface.  */
    struct in_addr imr_interface;	//本地的IP地址
  };
```

### 4.22 本地套接字通信

流程：

```c
//服务器端
1、创建一个 监听的套接字
    int lfd = socket(AF_UNIX/AF_LOCAL , SOCK_STREAM , 0);
2、绑定套接字
    struct  sockaddr_un addr;
	//绑定成功之后，指定的sun_path中的套接字文件会自动生成
	bind( lfd , addr, sizeof(addr));
3、监听
    listen( lfd , 100);
4、等待并接收连接请求
    struct  sockaddr_un client_addr;
	int client_fd = accept( lfd , &client_addr , len);
5、通信
    接收数据：read/recv
    发送数据：write/send
6、关闭连接
    close();
//---------------------------------
struct sockaddr_un
{
    __SOCKADDR_COMMON (sun_);
    char sun_path[108];		/* Path name.  */
};
//---------------------------------
//客户端
1、创建通信套接字
    int fd = socket(AF_UNIX/AF_LOCAL , SOCK_STREAM , 0);
2、绑定套接字
    struct  sockaddr_un addr;
	//绑定成功之后，指定的sun_path中的套接字文件会自动生成
	bind( fd , addr, sizeof(addr));
3、连接服务器
    struct  sockaddr_un server_addr;
    connect(fd , &server_addr , sizeof(server_addr));
4、通信
    接收数据：read/recv
    发送数据：write/send
5、关闭连接
    close();
```

