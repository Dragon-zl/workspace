## 第一章 Linux系统编程入门

### 1.1 GCC

#### 1.1.1 gcc编译流程

C文件 -> 预处理文件  ->  汇编文件  ->  链接 ->  可执行文件

命令：

```shell
gcc main.c -E -o main.i  |  gcc main.c -E
```

生成：预处理后的源代码  main.i

```shell
gcc main.i -S -o main.s  |  gcc main.c -生成：汇编代码  main.s
```

```shell
gcc  main.c  -o   main.o   -D DEBUG
```

作用：给程序指定一个宏

```shell
gcc main.c -o main.o  -Wall
```

作用：显示出所有的警告信息。

#### 1.1.2  gcc 和 g++的区别

1、gcc 和 g++ 都可以互相编译 .c或者.cpp文件 ， 但是gcc 不能自动和C++程序使用的库进行联接，所以习惯直接用g++编译.cpp文件。

2、__cplusplus 宏，只是标志着编译器将会把代码按 C 还是  C++ 语法来解释，也就是说，使用 gcc 去编译 .cpp文件，该宏是会被定义的。

3、编译可以用 gcc / g++ , 而链接可以用  g++   或者   gcc   -lstdc++ 。在编译阶段，g++ 自动调用了 gcc 。

### 1.2 静态库

#### 1.2.1 静态库的命名

Linux：libxxx.a  

#### 1.2.2 静态库的制作

1、gcc  获得  .o  文件

```shell
gcc -c  ***.c
```

2、将 .o  文件打包，使用  ar (archive)

```shell
ar   rcs   libxxx.a    xxx.o   xxx.o
```

r  : 将文件插入备存文件中

c  :  建立备存文件

s  :  索引

#### 1.2.2 静态库的使用

```shell
gcc    main.c   -o    app   -I   ./include/    -L   ./lib/    -l     静态库名
```

-I  : 指定头文件的位置

-L ：指定静态库的位置

-l  :  指定静态库的名称      **注意是静态库的名称，而不是静态库的文件名    比如 libcalc.a  静态库的名称为：calc**

### 1.3 动态库

#### 1.3.1 动态库的命名

Linux：libxxx.so

#### 1.3.2 动态库的制作

1、gcc 得到  .o  文件 ， 得到与位置无关的代码。

```shell
gcc  -c   -fpic/-fPIC   a.c   b.c
```

2、gcc  得到动态库

```shell
gcc  -shared   a.o  b.o  -o  libcalc.so
```

#### 1.3.3 动态库的使用原理

查看可执行文件依赖的动态库链接情况：

ldd   可执行文件

​		ldd app 
​        linux-vdso.so.1 (0x00007fff185ed000)   //  括号内的事动态库的内存地址
​        libcalc.so => not found
​        libc.so.6 => /lib64/libc.so.6 (0x00007f1c97da0000)
​        /lib64/ld-linux-x86-64.so.2 (0x00007f1c98165000)

当系统加载可执行代码时候，能够知道其所依赖的库的名字，但是还需要知道绝对路径。此时就需要系统的动态载入器来获取该绝对路径。

**系统是如何将动态库载入内存的？**

对于 elf 格式的可执行程序，是由 ld-linux.so 来完成的，它先后搜索 elf 文件的  DT_RPATH 段  ->  环境变量  LD_LIBRARY_PATH   ->  /etc/ld.so.cache 文件列表  ->  /lib/ , /usr/lib  目录找到库文件后将其载入内存。

#### 1.3.4 解决动态库链接失败的方法

**方法1** ：配置 LD_LIBRARY_PATH  （临时的)

export    LD_LIBRARY_PATH  =  $LD_LIBRARY_PATH:  /home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

查看是否配置成功： echo  LD_LIBRARY_PATH

:/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

**缺点**：这个环境变量只是临时的存在与终端，一旦终端关闭，就失效了。

**方法2** ：用户级别的永久配置

在家目录下 ： cd  ~/

打开 .bashrc 文件  :     vim   .bashrc

在最后一行添加：

export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib

更新 配置： .   .bashrc

**方法3** ：系统级别的永久配置

同样的方法，只不过是在  /ext/profile 文件的最后一行进行添加。

**方法4** ：配置  /etc/ld.so.cache  文件列表

将绝对路径：

/home/dzl/workspace/workspace/net_sever/lession3_动态库/lib  

添加到文件 /etc/ld.so.conf 的最后一行

更新： sudo  ldconfig

**方法4 ：** 将动态库文件添加到 /lib/ , /usr/lib  目录

**这种方法不推荐 ， 这很容易使得自己定义的库文件和系统的库文件产生冲突(重名 覆盖)**，

推荐：**方法2 3 4**

#### 1.3.5 静态库和动态库的优缺点

##### 静态库的优缺点：

###### 优点：

1、静态库被打包到应用程序中加载速度快

2、发布程序无需提供静态库，移植方便

###### 缺点：

1、消耗系统资源，浪费内存

2、更新、部署、发布麻烦

##### 动态库的优缺点：

###### 优点：

1、可以实现进程间资源共享 (共享库)

2、更新、部署、发布简单

3、可以控制何时加载动态库

###### 缺点：

1、相对来说，加载速度比静态库慢

2、发布程序时，需要提供依赖的动态库

### 1.4  Makefile

#### 1.4.1 makefile的作用

1、makefile文件定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，实现“自动化编译” 。

#### 1.4.2 makefile 规则

1、一个makefile 文件中可以有一个或者多个规则

​			目标  ....  ：依赖  .....

​					命令(shell  命令)

​					.....

目标：最终要生成的文件(伪目标除外)

依赖：生成目标文件所需要的文件或是目标

命令：通过执行命令对依赖操作生成目标(命令前必须 tab 缩进)

2、makefile中的其他规则一般都是为第一条规则服务的。

```makefile
app : main.c  printf.c
	gcc main.c printf.c -o app
```

#### 1.4.3 makefile的工作原理

1、命令在执行之前，需要先检查规则中的依赖是否存在

​		1.1 如果存在，执行命令

​		1.2 如果不存在，向下检查其他的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令。

```makefile
app : main.o  printf.o
	gcc main.o printf.o -o app
main.o : main.c
	gcc -c main.c -o main.o
printf.o : printf.c
	gcc -c printf.c -o printf.o
```

2、检查更新

2.1 如果依赖的最新更新时间比目标的时间晚，需要重新生成目标

2.2 如果依赖的最新更新时间比目标的时间早，目标不需要更新，对应规则中的命令不要被执行

```shell
[dzl@localhost lession4_makefile]$ make
make: “app”已是最新。
```

当我们只修改main.c时。

```shell
[dzl@localhost lession4_makefile]$ make
gcc -c main.c -o main.o
gcc main.o printf.o -o app
```

所以上面写的第二个版本的makefile比第一个版本的更好。

#### 1.4.4 变量

1、自定义变量

变量名=变量值		var=hello

2、预定义变量

AR：归档维护程序的名称，默认值为ar

CC：C 编译器的名称，默认值为 cc

CXX：C++ 编译器的名称，默认值为 g++

$@：目标的完整名称

$<：第一个依赖文件的名称

$^：所有的依赖文件

3、获取变量的值

$(变量名)

```makefile
src=main.o  printf.o
target=app
$(target) : $(src)
	$(CC) $^ -o $@
```

#### 1.4.5 模式匹配

```makefile
printf.o : printf.c
	gcc -c printf.c -o printf.o
```

%.o ：%.c

%：通配符，匹配一个字符串

两个%匹配的是同一个字符串

```makefile
%.o : %.c
	gcc -c $< -o $@
```

#### 1.4.6 函数

1、$(wildcard   PATTERN .... )

功能：获取指定目录下指定类型的文件列表

参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔

返回：得到的若干个文件的文件列表，文件名之间使用空格间隔

示例：

```makefile
$( wildcard  *.c  ./sub/*.c )
```

该函数，获取当前路径和当前路径下的sub路径下的 所以 .c 文件

返回值格式：a.c  b.c  c.c

2、$(patsubst  <pattern>,<replacement>,<text>)

功能：查找<text>中的单词(单词以‘空格’、"Tab"或"回车""换行" 分隔)是否符合模式<pattern>，如果匹配的话，则以<replacement>替换。

<pattern>可以包括通配符'%' , 表示任意长度的字串。如果<replacement>中也包含'%'，那么，<replacement>中的这个'%'将是<pattern>中的那个%所代表的字串。

返回：函数返回被替换过后的字符串

示例：

```makefile
$(patsubst  %.c , %.o , x.c bar.c)
```

返回值格式：x.o   bar.o

```makefile
src=$(wildcard  ./*.c)
objs=$(patsubst %.c , %.o , $(src))
target=app
$(target) : $(objs)
	$(CC) $(objs) -o $(target)
```

#### 1.4.7 clean 伪目标

由于clean并不依赖任何文件，所以为了使得make  clean那个执行

需要设置伪目标

```makefile
.PHONY:clean		#将clean设置为伪目标
clean:
	rm  $(objs)  -f
```

### 1.5  GDB 调试

#### 1.5.1 GDB 功能

1、启动程序

2、设置断点(断点可以是条件表达式)

3、咋程序停止时，可以检查程序中的某些事情，如果变量值

4、可以改变程序，将一个 bug 产生的影响修正，从而测试其他bug

#### 1.5.2 GDB 准备工作

1、在为调试而编译时，关掉编译器的优化选项('-o')，打开调试选项('-g')。另外，'-Wall' 打开所有warning。

示例：

```shell
gcc  -g   -Wall program.c  -o  program 
```

'-g' 选项的作用：在可执行文件中加入源代码的信息，所以在调试时，必须保证 gdb 能找到源文件。

#### 1.5.3 GDB命令 -- 启动、退出、 查看代码

开始：gdb   可执行文件

退出：quit / q

使用帮助：help

查看当前代码：

list / l     (从默认位置显示)

list / l     行号     (从指定的行显示)

list / l     函数名    (从指定的函数显示)

查看当前文件代码：

list  / l     文件名 ：行号

list  / l     文件名 ：函数名

显示 / 设置显示的行数：

show   list / listsize  

set   list / listsize   行数

#### 1.5.4 断点操作

**设置断点**

b/break   行号

b/break   函数名

b/break   文件名：行号

b/break	文件名：函数

**查看断点**

i/info	b/break

**删除断点**

d/del/delete	断点编号

**设置断点无效**

dis/disable	断点编号

```makefile
(gdb) disable 2
(gdb) info b
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000400601 in main at main.c:6
2       breakpoint     keep n   0x0000000000400664 in bubblesort at bubblesort.c:6
```

**设置断点生效**

ena/enable	断点编号

**设置条件断点(一般用在循环的位置)**

b/break	10	if	i==5

#### 1.5.5 调试命令

**运行GDB程序**

start	(程序停在第一行)

run	  (遇到断点才停)

**继续运行，到下一个断点停**

c/continue

**向下执行一行代码(不会进入函数体)**

n/next

**变量操作**

p/print	变量名(打印变量值)

ptype	  变量名(打印变量类型)

**向下单步调试(遇到函数进入函数体)**

s/step

finish（跳出函数体）

**自动变量操作**

display	num（自动打印指定变量的值）

i/info	display（查看设置的自动变量操作)

undisplay	编号	(删除设置的自动变量)

**其他操作**

set    var   变量名=变量值

until（跳出循环）

### 1.6 标准 C 库IO和Linux系统IO的区别

1、标准C库IO

例子：fopen   fclose    fread    fwrite   ...........  这些函数的底层是调用了Linux系统IO的函数 ，例如 read  write

可跨平台

缓冲区 -> 文件   ：即数据从内存刷新到磁盘

这个过程：1、刷新缓冲区:  fflush  函数   2、缓冲区已满   3、正常关闭文件

效率高：标准C库IO是带缓冲区的，默认的缓冲区大小  8192 byte

### 1.7  虚拟地址空间

下图示例为 32bit 的操作系统

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%89%9B%E5%AE%A2/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4.png)

### 1.8 文件描述符

文件描述符保存在内核区，有PCB(进程控制块)通过文件描述符表进行管理，每个进程拥有一个文件描述符表，文件描述符表是一个数组，默认的大小为 1024 。

每个文件描述符表：

默认已打开前三个文件描述符：

标准输入:		0 ->  STDIN_FILENO

标准输出:		1 ->  STDOUT_FILENO

标准错误：	 2 ->  STDERR_FILENO

这三个文件描述符都对应同一个终端：/dev/tty

### 1.9 Linux系统 IO 函数

**open 函数**

```c
int fd = open("open.c" , O_RDWR | O_CREAT , 0777 );
//  第三个参数mode 指定 被创建文件的权限  实际上结构是 0775(mode & umask)  umask : 0002
```

**lseek 函数**

```c
off_t lseek(int fd, off_t offset, int whence);
/*
	返回值：文件指针的位置
	参数：whence
		 SEEK_SET
		 	设置文件指针的偏移量
          SEEK_CUR
             设置偏移量：当前位置 + 第二个参数 offset
          SEEK_END
             设置偏移量：文件大小 + 第二个参数 offset
*/
/*
	该函数主要用于：
		1、移动文件指针到文件头
		lseek(fd, 0, SEEK_SET);
		2、获取当前文件指针的位置
		lseek(fd, 0, SEEK_CUR);
		3、获取文件的大小
		lseek(fd, 0, SEEK_END);
		4、拓展文件的长度，例如 10b -> 110b
		lseek(fd, 100, SEEK_END);
		移动指针后需要写入一个空数据：write(fd , " " , 1);
*/
```

**stat 和 lstat 函数**

stat 

```shell
[dzl@localhost lession6_Linux文件IO]$ stat open.c 
  文件：open.c
  大小：0               块：0          IO 块：4096   普通空文件
设备：fd02h/64770d      Inode：50455829    硬链接：1
权限：(0775/-rwxrwxr-x)  Uid：( 1000/     dzl)   Gid：( 1000/     dzl)
最近访问：2021-11-10 20:49:08.355865686 +0800
最近更改：2021-11-10 20:49:08.355865686 +0800
最近改动：2021-11-10 20:49:08.355865686 +0800
创建时间：2021-11-10 20:49:08.355865686 +0800
```

```c
int stat(const char *pathname, struct stat *statbuf);
/*
	作用：获取一个文件的相关信息
	参数：struct stat *statbuf
	statbuf：结构体指针变量，传出参数，用于保存获取的文件信息
*/
```

stat 结构体的各个成员变量

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/stat%E7%BB%93%E6%9E%84%E4%BD%93.png)

其中比较重要的一个成员变量：st_mode

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/st_mode%E5%8F%98%E9%87%8F.png)

lstat 

```c
int lstat(const char *pathname, struct stat *statbuf);
该函数参数与 stat 一样，这个函数用于获取软连接文件的信息
```

```shell
ln -s open.c lopen.c
```

为open.c 函数创建一个软连接文件lopen.c

```shell
[dzl@localhost lession6_Linux文件IO]$ ln -s open.c lopen.c
[dzl@localhost lession6_Linux文件IO]$ ll
总用量 24
lrwxrwxrwx 1 dzl dzl     6 十一月 10 22:13 lopen.c -> open.c
-rwxrwxr-x 1 dzl dzl 17584 十一月 10 20:49 main
-rw-rw-r-- 1 dzl dzl   338 十一月 10 22:10 main.c
-rwxrwxr-x 1 dzl dzl     0 十一月 10 20:49 open.c
```

## 第二章 linux多进程开发

### 2.1 进程概述

#### 2.1.1 时间片

在Linux上CPU为每个进程分配的时间 为 5ms - 800ms

首先，内核为所有的进程分配相等的初始化时间片，当所有进程都消耗掉时间片后，内核再重新为每个进程进行分配时间片，如此往复。

#### 2.1.2 并行、并发

并行：同一个时刻有多条指令在多个处理器上执行

并发：同一时刻只有一条指令执行，多个进程指令快速的轮番执行。

#### 2.1.3 进程控制块

内核为每个进程分配了一个 PCB(processing  control  block)进程控制快，维护进程相关信息，Linux的内核控制块是 task_struct 结构体。

### 2.2 进程的状态转换

#### 2.2.1 进程的状态

三态模型：就绪态，运行态，阻塞态

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81_%E4%B8%89%E6%80%81.png)

五态模型：新建态，就绪态，运行态，阻塞态，终止态

#### 2.2.2 进程相关命令

查看进程

ps  aux / ajx

a：显示终端上的所有进程，包括其它用户的进程

u：显示进程的详细信息

x：显示没有控制终端的进程

j：列出与作业控制相关的信息

![进程_状态参数](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/进程_状态参数.png)

![实时显示_进程动态](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/实时显示_进程动态.png)

### 2.3  创建进程

#### 2.3.1 进程创建

系统允许一个进程创建新进程，即创建子进程，子进程也可以创建新的子进程，形成进程树结构类型。

##### 父子进程的虚拟地址空间

Linux的fork()函数采用 **写时拷贝(copy -on- write)** 实现

写时拷贝：

父子进程在对地址空间的读操作上，是共享的，子进程共享父进程，但是一旦父进程或者子进程有写的操作，就会复制 新的物理内存。如此来提高效率且不冲突。

##### 父子进程的关系

区别：

1、fork()函数的返回值：父进程返回的是子进程的PID，子进程返回的是0

2、pcb中的一些数据

​			当前进程的 ID ，pid

​			当前进程的父进程id和ppid

​			信号集

共同点：

​	某些状态下：子进程被创建出来，还没有执行写操作时

 - 用户去的数据
 - 文件描述符表

父子进程之间对变量是不是共享的：

1、刚开始的时候，是一样的，共享的。如果修改了数据，就不共享了。总结为 ：读时共享，写时拷贝

#### 2.3.2 GDB多进程调试

GDB调试默认跟踪的是父进程，可以在fork函数调用之前，使用指令设置 GDB 调试工具追踪父进程或者子进程。

1、设置跟踪父子进程的指令：

set  follow-fork-mod  [parent(默认) | child]

2、设置其他指令是否脱离GDB的指令：

set  detach-on-fork  [on(默认) | off]

默认为on，即表示调试当前进程的时候，其他的进程继续运行，如果为off，调试当前进程的时候，其他进程被GDB挂起。

3、查看调试的进程编号

info  inferiors

4、切换当前调试的进程

inferior  id

5、使进程脱离 GDB 调试

detach  inferiors  id

### 2.4 exec 函数族

#### 2.4.1 介绍

exec 函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容。换句话说，就是在调用进程内部执行一个可执行文件。

执行成功后不会返回，失败返回-1

exec 函数一般用于子进程调用

![exec函数族](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/exec函数族.png)

### 2.5 进程退出、孤儿进程、僵尸进程

#### 2.5.1 进程退出

标准 C 库里函数：

```c
#include <stdlib.h>
void  exit( int status );
```

Linux环境函数：

```c
#include <unistd.h>
void _exit( int status );
```

两者的实现过程：

![exit与_exit函数的工作过程](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/exit%E4%B8%8E_exit%E5%87%BD%E6%95%B0%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png)

大多情况都会使用标准C库的 exit函数

#### 2.5.2 孤儿进程

概述：父进程运行结束，但子进程还在运行，即称为孤儿进程

孤儿进程回收过程：每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为 init ， 二 init 进程会循环地 wait() 它的子进程退出。所以即 init 来处理孤儿进程的善后工作。

init 进程的pid为 1 ， 即系统的第一个进程。

因此，孤儿进程并不会有什么危害。

#### 2.5.3 僵尸进程

概述：每个进程结束之后，都会释放自己地址空间中的用户区数据，内核去的 PCB 没有办法自己释放掉，需要父进程去释放。进程终止时，父进程尚未回收，子进程残留资源（PCB）存放于内核中，变成僵尸(Zombie)进程。

![僵尸进程](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B.png)

### 2.6 wait 、waitpid 函数

wait 和 waitpid 函数功能一样，区别在于，wait() 函数会阻塞，waitpid() 可以设置不阻塞。

一次 wait 或者 waitpid 只能清理一个子进程，清理多个使用循环。

![进程退出相关宏参数](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA%E7%9B%B8%E5%85%B3%E5%AE%8F%E5%8F%82%E6%95%B0.png)



### 2.7 进程间通信

进程间通信( IPC: Inter  Processes Communication )

![](E:\My_workspace\牛客\picture\Linux进程间通信.png)

#### 2.7.1 匿名(无名)管道

举例：统计一个目录中文件的数目命令：ls  |  wc  -l  ，为了执行该命令，shell 创建了两个进程来分别执行 ls 和 wc。

![](E:\My_workspace\牛客\picture\无名管道.png)

**管道的特点：**

1、管道其实是一个在内核内存中维护的缓冲器，这个缓冲器的存储能力是有限的，不同的操作系统大小不一定相同。

2、管道拥有文件的特质：读操作、写操作，匿名管道没有文件实体，有名管道有文件实体，单不存储数据。可以按照操作文件的方式对管道进行操作。

3、一个管道是一个字节流，使用管道时不存在消息或者消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，而不管写入进程写入管道的数据块的大小是多少。

4、通过管道传输的数据是顺序的，从管道中读取出来的字节的顺序和它们被写入管道的顺序是完全一样的。

5、在管道中的数据的传递方向是单向的，一端用于写入，一端用于读取，管道时半双工的。

6、从管道读数据时一次性操作，数据一旦被读走，它就从管道中被抛弃，释放空间以便写更多的数据，在管道中无法使用 lseek() 来随机的访问数据。

7、匿名管道只能在具有公共祖先的进程(父进程与子进程，或者两个兄弟进程，具有亲缘关系)之间的使用。

**管道的数据结构为：环形队列**

#### 2.7.2 管道读写的特点

以下情况为阻塞型管道

1、写端全部关闭，read 返回0(相当于读到文件末尾)。

2、读端全部关闭 ，对管道进行write的进程会收到一个信号 SIGPIPE，通常会导致进程异常终止。

3、管道中缓冲数据已满，write则会阻塞

#### 2.7.3 有名管道

与匿名管道不同点：

1、FIFO 在文件系统中作为一个特殊文件存在，但 FIFO 中的内容却存放在内存中

2、当使用 FIFO 的进程退出后，FIFO 文件将继续保存在文件系统中以便以后使用

3、FIFO 有名字，不相关的进程可以通过打开有名管道进行通信

**如何使用**

1、key通过命令创建有名管道

mkfifo   名字

2、通过函数创建有名管道，FIFO 和普通文件一样，但不支持 lseek()等文件定位操作。

### 2.8 内存映射

注意事项：

1、调用mmap函数时，设置文件的偏移量为 1000 会怎么样？

答：失败 ，返回MAP_FAILED ， 因为偏移量必须死 4K 的整数倍。

2、mmap函数什么情况下会调用失败？

答：

 - 第二个参数：length = 0
 - 第三个参数：port 
    - 只定义了写权限
    - 定义的权限 > fd在打开文件时的权限

3、可以open的时候O_CREAT一个新文件来创建映射区吗？

 - 可以 ， 但是创建的文件的大小如果为 0 的话，肯定不行

   所以需要对新的文件进行扩展

   - lseek()
   - truncate()

### 2.9 信号集及相关函数

信号的特点

- 简单
- 不能携带大量信息
- 满足某个特定条件才发送
- 优先级比较高

查看系统定义的信号列表：kill   -l

前 31 个信号为常规信号，其余为实时信号

**信号的5种默认处理动作**

- 查看信号的详细信息：man  7  signal

- 信号的 5 种默认处理动作

  - Term		终止进程

  - Ign           当前进程忽略掉这个信号

  - Core        终止进程，并生成一个Core文件

  - Stop        暂停当前进程

  - Cont        继续执行当前被暂停的进程

    

信号的几种状态：产生、未决、递达

SIGKILL 和  SIGSTOP  信号不能被捕捉、阻塞或者忽略，只能执行默认动作。

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/%E9%98%BB%E5%A1%9E%E4%BF%A1%E5%8F%B7_%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86.png)

信号集：

1、用户通过键盘 Ctrl  +  C ，产生 2 号信号SIGINT（信号被创建）

2、信号产生但是没有被处理（未决）

 - 在内核中将所有的没有被处理的新号存储在一个集合中（未决信号集）

 - SIGINT信号状态被存储在第二个标志位上

    - 标志位为 1 ，信号处于未决状态

    - 标志位为 0 ，信号不是未决状态

      

3、未决信号需要被处理，未决信号集通过查看比较阻塞信号集的信号阻塞状态，来判断

信号是否被发送给进程处理，进而判断信号的状态是未决或非未决，从而判断是否修改未决标志位。

	- 阻塞信号集默认不阻塞所有信号
	- 如果想要阻塞某个信号需要用户调用系统的API

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89.png)

### 2.10 共享内存 （效率最高的进程间通信）

概述：

共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分，因此这种 IPC 机制无需内核介入。

**共享内存使用步骤：**

1、shmget() 创建一个新的共享内存段 或 获取一个已存在的共享内存段 ，返回共享内存标识符

2、shmat() 设置共享内存段成为调用进程的虚拟内存的一部分，返回值为共享内存段的首地址

3、shmdt() 分离共享内存段，该函数是可选的，进程结束时会自动调用该函数

4、shmctl() 操作共享内存段(主要用于删除)，只有当所有附加内存端的进程与之分离之后，才会销毁，只有一个进程需要执行这一步。

**思考问题**

1、操作系统如何知道一块共享内存被多少个进程关联？

 -	共享内存维护了一个结构体 struct shmid_ds ，该结构体有一个成员 shm_nattch
 -	shm_nattch 记录了关联的进程个数

2、共享内存和内存映射的区别

 - 共享内存可以直接创建，内存映射需要磁盘文件(匿名映射除外，但匿名映射只能用于有亲缘关系的进程)

 - 共享内存效率更高

 - 内存映射所有的进程操作的都是同一块共享内存，而内存映射，每个进程在自己的虚拟地址空间中有一块独立的内存

 - 数据安全

   - 进程突然退出

     共享内存还存在

     内存映射区消失

   - 运行进程的电脑死机，宕机了

     存在共享内存中的数据，没有了

     存在内存映射区的数据，由于磁盘文件还存在，数据还存在

     

- 生命周期

  - 内存映射区：进程退出，内存映射区销毁

  - 共享内存：进程退出，共享内存还在，标记删除(关联的所有进程数为0)，或者关机

     如果进程退出，会自动取消关联

### 2.11 守护进程

概述：

守护进程（Daemon Process），也称之为 Daemon 进程（精灵进程），是Linux中的后台服务进程。一般采用 d 结尾的名字。

守护进程的特征：

1、生命周期很长，守护进程会在系统启动的时候被创建并一直运行直至系统被关闭。

2、它在后台运行并且不拥有控制终端。没有控制终端确保了内核永远不会为守护进程自动生成任何控制信号以及终端相关的信号，如（SIGINT 、SIGQUIT）。

Linux 的大多数服务器就是用守护进程实现的。比如，Internet   服务器 inetd ，Web 服务器 httpd 等。

**守护进程的创建步骤**

1、执行一个 fork()，之后父进程退出，子进程继续执行

2、子进程调用 setsid() 开启一个新会话

3、清除进程的 umask 以确保当守护进程创建文件和目录时拥有所需的权限

4、修改进程的当前工作目录，通常会改为根目录（/）

5、关闭守护进程从其父进程继承而来的所有打开着的文件描述符

6、关闭了文件描述符 0、1、2 之后，守护进程通常会打开/dev/null  并使用 dup2()重定向 文件描述符 0、1、2，使其指向/dev/null 设备，在该设备上打印信息会被系统丢弃。

7、核心业务逻辑

## 第三章 Linux多线程

### 3.1 线程概述_创建线程

#### 概述

1、进程是 CPU分配资源的最小单位，线程是操作系统调度执行的最小单位。

2、线程是轻量级的进程（LWP:Light  Weight  Process) ,在Linux环境下线车的本质仍是进程

3、查看指定进程的 LWP 号： ps  -Lf    pid

#### 创建线程

一般情况下，main函数所在的线程称之为 主线程 ， 其余创建的线程称之为子线程。

### 3.2 互斥锁

一旦线程锁定互斥量，随机成为该互斥量的所有者，只有所有者才能给互斥量解锁。

### 3.4 条件变量

条件变量不是锁，它可以阻塞线程，当满足某个条件后解除阻塞

### 3.5 读写锁

特点：

1、当线程读数据，则允许其他线程执行读操作，但不允许写操作

2、当线程写数据，则其它线程都不允许读、写操作

3、写是独占的，写的优先级高

读写锁的效率比 互斥锁更高

### 3.6 生产者和消费者模型

组成部分：

1、生产者

2、消费者

3、容器

关系：

1、生产者和消费者，都共用着容器，这里需要对容器加锁

2、当容器没有任务，消费者需要提醒生产者生产，当生产者产生了任务到容器，需要提醒消费者消费，这里需要线程之间的通信，条件变量、信号量。



## 第 四 章  Linux网络编程

### 4.1 网络结构模式

#### C/S结构

##### 简介

客户机-服务器 ， 即 Client - Sever 结构

#### B/S 结构

##### 简介

Browser/Sever , 浏览器/服务器模式，

### 4.2 MAC地址  IP地址

#### MAC地址

MAC地址（Media  Access  Control  Address），直译媒体存取控制位址，也称为局域网地址、以太网地址、物理地址和硬件地址。它是一个用来确认网络设备位置的位址。

​	在OSI模型中，第三层网络层负责 IP 地址，第二层数据链路层负责MAC 位址。

##### 唯一性

MAC地址的长度为 48位（6个字节），如 00-16-EA-AE-3C-40 ,其中前 3 个字节，00-16-EA 代表网络硬件制造商的编号，由 IEEE 协会提供，而后 3 个字节，AE-3C-40 ， 代表制造商所制造的某个网络产品的系列号，理论上，MAC地址就像身份证一样，全球都是唯一的。

所以，可以通过MAC地址，找到网卡硬件设备。

#### IP 地址

IP （Internet  protocol  Address）地址是指互联网协议地址，属于逻辑地址，虚拟的。

IP 由 4个字节 32位 组成，通常用 点分十进制 形式表示，

##### IP地址编址方式

IP地址分为 A ~ E 五类

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture/%E7%89%9B%E5%AE%A2/IP%E5%9C%B0%E5%9D%80%E5%88%86%E7%B1%BB.png)

###### A类地址

由一个 字节的网络地址 和 3 个字节的主机地址组成，网络地址的最高位必须是 “0” ， 所以有 126 个网络 。

A类 IP地址的子网掩码为 255.0.0.0 ， 每个网络支持的最大主机数为 256 的3次方  - 2 = 16777214。

其它类型地址 请看课件....

###### 特殊的网址

IP地址中不能以十进制 “127” ，作为开头，该类地址中数字 127.0.0.1 到 127.255.255.255 用于回路测试，如：127.0.0.1 可以代表本机 IP 地址。

#### 子网掩码

子网掩码只有一个作用，就是将某个IP地址划分为网络地址和主机地址两部分。用于屏蔽 IP 地址的一部分以区别网络标识和主机标识。并说明该 IP 地址是在局域网上还是广域网上。

比如 C类地址的子网掩码：255.255.255.0

#### 端口

##### 简介：

物理端口又称为接口，TCP/IP协议中的端口为逻辑端口（虚拟的）。

端口由 2 个字节组成，所以一个 IP 地址可以有 端口号的范围为 0 ~ 65536 。端口号可以标识进程，通过端口号可以找到进程，端口也是在TCP/IP通讯中起到了缓冲区的作用。

##### 端口类型

###### 周知端口

绑定某些服务的端口，例如 80 端口分配给 WWW 服务，21 端口分配给 FTP服务，23 端口分配给 Talnet 服务等等。

###### 注册端口

应用程序一般使用该类型端口好 ， 端口号从 1024 到 49151。

### 4.3 网络模型

#### 七层参考模型 OSI

#### TCP/IP 四层模型

![](E:\My_workspace\牛客\picture\TCP_IP四层模型.png)

### 4.4 协议

#### 常见协议

##### 应用层常见协议：

FTP 协议（File Transfer  Protocol 文件传输协议）、HTTP 协议（Hyper  Text  Transfer Protocol 超文本传输协议）、NFS （Network  File  System 网络文件系统）。

![](E:\My_workspace\牛客\picture\四层模型_相关协议.png)

#### UDP协议

![](E:\My_workspace\牛客\picture\UDP协议.png)

#### TCP协议

![](E:\My_workspace\牛客\picture\TCP协议框架图.png)

![](E:\My_workspace\牛客\picture\TCP协议详细.png)

![](E:\My_workspace\牛客\picture\TCP协议详细_2.png)

#### IP 协议

![](E:\My_workspace\牛客\picture\IP协议.png)

![](E:\My_workspace\牛客\picture\IP协议_2.png)

#### ARP 协议

![](E:\My_workspace\牛客\picture\ARP协议.png)

### 4.5 网络通信的过程

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B_%E5%B0%81%E8%A3%85.png)

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%9A%84%E8%BF%87%E7%A8%8B_%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)

#### ARP通信过程

![](E:/Guangdong_inlay/Linux_study/Typora_md_file/picture_nowcoder/arp%E8%AF%B7%E6%B1%82%E5%B0%81%E8%A3%85.png)

### 4.6 Socket

套接字上联应用进程，下联网络协议栈，是应用程序通过网络协议进程通信的接口，是应用程序与网络协议根进行交互的接口。

socket 由 IP 和 端口结合的，提供向应用层进程传送数据包的机制。

### 4.7  字节序

#### 概述

字节序，分为大端字节序和小端字节序。

小端字节序：高位地址存高位字节，低位地址存低位字节

大端字节序：高位地址存低位字节，低位地址存高位字节

绝大部分计算机：

小端字节序

#### 字节序转换函数

为了解决可能存在的不同 机型的通信时数据解析问题，

行业规定：发送端在发送时，总是先把数据转换成大端字节序数据后再发送，接收端根据自身的字节序判断是否需要进行转换。

所以，网络字节序即为大端，主机字节序则根据机型而分。

```c
/*
h   --  host 主机，主机字节序
to  --  转换
n   --  network 网络字节序
s   --  unsigned  short 
l   --  long == unsigned int
*/
#include <arpa/inet.h>
//转换端口
uint16_t htons(uint16_t hostshort);  //主机字节序 -》 网络字节序
uint16_t ntohs(uint16_t netshort);   //网络字节序 -》 主机字节序
//转换 IP
uint32_t htonl(uint32_t hostlong);   //主机字节序 -》 网络字节序
uint32_t ntohl(uint32_t netlong);    //网络字节序 -》 主机字节序

```

### 4.8 socket地址

```c
/*
socket地址是一个结构体，封装端口号和IP等信息
socket网络编程中表示socket地址的是结构体sockaddr，其定义如下：
struct  sockaddr{
	sa_family_t  sa_family;
	char         sa_data[14];
};
typedef  unsigned  short  int  sa_family_t;


*/
```

### 4.9 IP 地址转换函数（字符串ip - 整数，主机、网络字节序的转换）

```c
#include <arpa/inet.h>
/*
p:点分十进制的IP字符串
n：表示network，网络字节序的整数
*/
//功能：将点分十进制的IP字符串，转换为网络字节序的整数
/*
参数：
af：协议族：AF_INET or AF_INET6
src：需要转换的点分十进制的IP字符串
dst：转换后的结果保存在这里面
*/
int inet_pton(int af, const char *src, void *dst);

/*
功能：将网络字节序的整数，转换为点分十进制的IP字符串
参数：
af：协议族：AF_INET or AF_INET6
src：需要转换的网络字节序的整数
dst：转换后的IP字符串的首地址
size：dst字符串的长度
返回值：
返回转换后的字符串的首地址，和dst是同一个值。
*/
const char *inet_ntop(int af, const void *src,
                             char *dst, socklen_t size);

```

### 4.10 TCP 通信流程

```c
//TCP 和 UDP    --- 传输层的协议
UDP：
    用户数据报协议
    面向无连接，可以单播、多播、广播，面向数据报，不可靠
TCP：
    传输控制协议
    面向连接的，可靠的，基于字节流的传输协议，仅支持单播传输，即点对点传输
```

![](E:\Guangdong_inlay\Linux_study\Typora_md_file\picture_nowcoder\第四章_Linux网络编程\TCP通信流程图.png)

### 4.11 socket 函数

```c
#include <sys/types.h>      
#include <sys/socket.h>
#include <arpa/inet.h>	//包含了这个头文件，上面两个就可以省略
int socket(int domain, int type, int protocol);
-功能：创建一个套接字
-参数：
    domain：协议族
    	AF_INET ：ipv4
    	AF_INET ：ipv6
    	AF_UNIX ，AF_LOCAL ：本地套接字通信(进程间通信)
    type：通信过程中使用的协议类型
   		SOCK_STREAM：流式协议
    	SOCK_DGRAM ：报式协议
    protocol：具体的一个协议，一般写 0 
    	SOCK_STREAM：流式协议 ， 默认使用 TCP
    	SOCK_DGRAM ：报式协议 ， 默认使用 UDP
-返回值
    成功：返回文件描述符，操作的是内核缓冲区。
   	失败：返回 -1
int bind(int sockfd, const struct sockaddr *addr,
                socklen_t addrlen);
功能：绑定，将fd和本地的 IP 、端口号进行绑定
参数：
    sockfd：使用socket函数，得到的文件描述符
    addr：需要绑定的socket地址，这个地址封装了ip和端口的信息
    addrlen：第二个参数结构体占的内存大小
int listen(int sockfd, int backlog);
功能：监听这个socket上的连接
参数：
    sockfd：socket函数得到的文件描述符
    backlog：（listen在底层有两个队列，一个为未连接队列，一个为已连接队列）
    	未连接和已连接的和的最大值，一般这个值取 5 ，够用了。
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
功能：接收客户端连接，默认是一个阻塞的函数，阻塞等待客户端连接
参数：
    sockfd：socket函数得到的文件描述符
    addr：需要绑定的socket地址，这个地址封装了ip和端口的信息
    addrlen：第二个参数结构体占的内存大小的指针
返回值：
    成功：返回用于通信的文件描述符
    失败：-1
int connect(int sockfd, const struct sockaddr *addr,
                   socklen_t addrlen);
功能：客户端连接服务器
参数：
    sockfd：通讯的文件描述符，客户端是由socket函数产生
    addr：需要绑定的socket地址，这个地址封装了ip和端口的信息
    addrlen：第二个参数结构体占的内存大小
返回值：
    成功：0
    失败：-1
ssize_t write(int fd, const void *buf, size_t count);
ssize_t read(int fd, void *buf, size_t count);
```

